(this["webpackJsonppath-game"]=this["webpackJsonppath-game"]||[]).push([[0],{17:function(e,t,l){},24:function(e,t,l){},26:function(e,t,l){"use strict";l.r(t);var i=l(0),s=l(5),r=l.n(s),o=(l(17),l(3));l(24);const n=e=>({type:"NEW_GAME",text:e}),a=e=>({type:"VISIT_VERTEX",id:e}),c=e=>({type:"RESET_LEVEL",id:e});var d=l(1);class h extends i.Component{render(){let e=this.props,t=e.tile,l=e.tileState,i=e.tileSize,s=e.edgeSize,r=["tile",t.tileType,l.valid?" valid":" invalid"];return t.symbol&&(r.push("symbol"),r.push("symbol-"+t.symbol)),Object(d.jsx)("div",{className:r.join(" "),style:{width:i,height:i,left:t.x1*(i+s),top:t.y1*(i+s),color:t.color||"black"}})}}var p=h;class v extends i.Component{render(){let e=this.props,t=e.edge,l=e.edgeState,i=e.tileSize,s=e.edgeSize;return t.x1===t.x2?Object(d.jsx)("div",{className:"edge vertical"+(l.visited?" visited":"")+(t.broken?" broken":""),style:{width:s,height:i,left:t.x1*(i+s)-s,top:t.y1*(i+s)}}):Object(d.jsx)("div",{className:"edge horizontal"+(l.visited?" visited":"")+(t.broken?" broken":""),style:{width:i,height:s,left:t.x1*(i+s),top:t.y1*(i+s)-s}})}}var g=v;class u extends i.Component{render(){let e=this.props,t=e.vertex,l=e.vertexState,i=e.tileSize,s=e.edgeSize;return"entry"===t.vertexType||"exit"===t.vertexType?Object(d.jsx)("div",{className:"vertex "+(t.vertexType||"")+(l.visited?" visited":""),style:{width:3*s,height:3*s,left:t.x*(i+s)-s-s,top:t.y*(i+s)-s-s}}):Object(d.jsx)("div",{className:"vertex "+(t.vertexType||"")+(l.visited?" visited":""),style:{width:s,height:s,left:t.x*(i+s)-s,top:t.y*(i+s)-s}})}}var b=u;class f extends i.Component{constructor(){super(),this.onMouseDown=this.onMouseDown.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.state={},this.dragging=!1}componentDidMount(){this.div.addEventListener("touchstart",this.onMouseDown),this.div.addEventListener("touchmove",this.onMouseMove,{passive:!1}),this.div.addEventListener("touchend",this.onMouseUp)}onMouseDown(e){this.dragging=!0}onMouseMove(e){if(!this.dragging)return;let t,l,i=this.props,s=i.level,r=i.visitVertex,o=i.tileSize,n=i.edgeSize;if(e.targetTouches?(t=e.targetTouches[0],l=e.target,e.preventDefault()):(t=e.nativeEvent,l=e.nativeEvent.target),!t||!l)return;let a=t.clientX-l.offsetLeft,c=t.clientY-l.offsetTop,d=Math.round(a/(o+n))-1,h=Math.round(c/(o+n))-1;if(console.log(a+", "+c+" => "+d+", "+h),d>=0&&h>=0&&h<=s.rows&&d<=s.cols){r(h*(s.cols+1)+d)}}onMouseUp(e){if(!this.dragging)return;this.dragging=!1;let t,l,i=this.props,s=i.level,r=i.visitVertex,o=i.tileSize,n=i.edgeSize;if(e.targetTouches?(t=e.targetTouches[0],l=e.target):(t=e.nativeEvent,l=e.nativeEvent.target),!t||!l)return;let a=t.clientX-l.offsetLeft,c=t.clientY-l.offsetTop,d=Math.round(a/(o+n))-1,h=Math.round(c/(o+n))-1;if(console.log(a+", "+c+" => "+d+", "+h),d>=0&&h>=0&&h<=s.rows&&d<=s.cols){r(h*(s.cols+1)+d)}}render(){let e=this.props,t=e.level,l=e.tileSize,i=e.edgeSize,s=e.boardSize,r=e.vMargin,o=e.hMargin;if(t&&t.tiles&&t.tiles[0]){let e=null;return(t.completed&&!t.won||t.completed&&t.won)&&(e=Object(d.jsx)("div",{className:"boardOverlay"})),Object(d.jsxs)("div",{className:"board "+(t.completed?" completed":"")+(t.won?" won":""),ref:e=>this.div=e,onMouseDown:this.onMouseDown,onMouseMove:this.onMouseMove,onMouseUp:this.onMouseUp,style:{marginTop:r,marginBottom:r,marginLeft:o,marginRight:o,width:s,height:s},children:[t.tiles.map(((e,s)=>Object(d.jsx)(p,{tile:e,tileState:t.tileState[s],tileSize:l,edgeSize:i},s))),t.edges.map(((e,s)=>Object(d.jsx)(g,{edge:e,edgeId:s,edgeState:t.edgeState[s],tileSize:l,edgeSize:i},s))),t.vertices.map(((e,s)=>Object(d.jsx)(b,{vertex:e,vertexId:s,vertexState:t.vertexState[s],tileSize:l,edgeSize:i},s))),e]})}return Object(d.jsx)("div",{className:"board",children:"No game loaded;"})}}var m=Object(o.b)((e=>({})),(e=>({resetLevel:t=>e(c(t)),newGame:t=>e(n(t)),visitVertex:t=>e(a(t))})))(f);class j extends i.Component{constructor(){super(),this.state={tileSize:50,edgeSize:10},this.updateSize=this.updateSize.bind(this)}static getDerivedStateFromProps(e,t){return t.level&&e.level?t.level&&e.level&&t.level.levelId!==e.level.levelId?(console.log("resetting"),{nextLevel:e.level,level:null,prevLevel:t.level}):(!t.level.completed&&e.level.completed&&(e.level.won?setTimeout((()=>e.newGame()),500):setTimeout((()=>e.resetLevel()),1e3)),{nextLevel:null,level:e.level,prevLevel:null}):{nextLevel:null,level:e.level,prevLevel:null}}updateSize(){if(!this.div)return;let e=this.div.getBoundingClientRect(),t=Math.min(Math.min(e.width,e.height)-20,600),l=t/60,i=t/(this.props.level.cols+2)-l;this.setState({boardSize:t,vMargin:(e.height-t)/2,hMargin:(e.width-t)/2,tileSize:i,edgeSize:l})}componentDidMount(){this.updateSize(),window.addEventListener("resize",this.updateSize)}componentWillUnmount(){window.removeEventListener("resize",this.updateSize)}render(){let e=this.state,t=e.level,l=e.prevLevel,i=e.nextLevel,s=e.tileSize,r=e.edgeSize,o=e.boardSize,n=e.vMargin,a=e.hMargin;return Object(d.jsxs)("div",{className:"boardcontainer",ref:e=>this.div=e,onClick:this.onClick,children:[l?Object(d.jsx)("div",{className:"prevLevel",children:Object(d.jsx)(m,{level:l,tileSize:s,edgeSize:r,boardSize:o,vMargin:n,hMargin:a})}):null,t?Object(d.jsx)("div",{className:"currentLevel",children:Object(d.jsx)(m,{level:t,tileSize:s,edgeSize:r,boardSize:o,vMargin:n,hMargin:a})}):null,i?Object(d.jsx)("div",{className:"nextLevel",children:Object(d.jsx)(m,{level:i,tileSize:s,edgeSize:r,boardSize:o,vMargin:n,hMargin:a})}):null]})}}var x=Object(o.b)((e=>({level:e.level})),(e=>({resetLevel:t=>e(c(t)),newGame:t=>e(n(t)),visitVertex:t=>e(a(t))})))(j);class y extends i.Component{render(){let e=this.props,t=e.newGame,l=e.resetLevel,i=e.showLevelSelect,s=e.showRules,r=e.progress;return Object(d.jsxs)("div",{className:"menu",children:[Object(d.jsx)("button",{onClick:()=>t(),children:"New Game"}),Object(d.jsx)("button",{onClick:()=>l(),children:"Retry"}),Object(d.jsxs)("button",{onClick:()=>i(),children:["Level ",r.currentDifficulty]}),Object(d.jsx)("button",{onClick:()=>s(),children:"Rules"})]})}}var S=Object(o.b)((e=>({progress:e.progress,level:e.level})),(e=>({resetLevel:t=>e(c(t)),newGame:t=>e(n(t)),showLevelSelect:t=>e((e=>({type:"SHOW_LEVEL_SELECT",id:e}))(t)),showRules:t=>e((e=>({type:"SHOW_RULES",id:e}))(t))})))(y);class O extends i.Component{render(){let e=this.props,t=e.tileSpec,l=e.updateTileDescription;return Object(d.jsxs)("div",{className:"rulesrow",children:[Object(d.jsx)("div",{className:"tile symbol symbol-"+t.symbol}),Object(d.jsx)("textarea",{value:t.description,onChange:e=>{l(e.target.value)},placeholder:"Tap to edit when you know the rules"})]})}}class M extends i.Component{render(){let e=this.props,t=e.hideRules,l=e.visible,i=e.progress,s=e.updateTileDescription;return Object(d.jsx)("div",{className:"modalpage "+(l?"visible":"hidden"),children:Object(d.jsxs)("div",{className:"contentbox",children:[Object(d.jsx)("h1",{children:"Rules"}),Object(d.jsx)("p",{style:{maxWidth:550,margin:"auto",marginBottom:50},children:"Draw a line from the start to the finish, separating the board into regions matching the tile rules below."}),i.tileTypes.map(((e,t)=>Object(d.jsx)(O,{tileSpec:e,updateTileDescription:e=>s(t,e)},t))),Object(d.jsx)("button",{className:"donebutton",onClick:()=>t(),children:"Done"})]})})}}var T=Object(o.b)((e=>({progress:e.progress,visible:e.rulesShown})),(e=>({hideRules:t=>e((e=>({type:"HIDE_RULES",id:e}))(t)),updateTileDescription:(t,l)=>e(((e,t)=>({type:"UPDATE_TILE_DESCRIPTION",id:e,description:t}))(t,l))})))(M);class w extends i.Component{render(){let e=this.props,t=e.tileSpec,l=e.setCurrentDifficulty,i=e.difficulty,s=e.selected;return Object(d.jsxs)("div",{className:"rulesrow"+(s?" selected":""),onClick:()=>l(i),children:[Object(d.jsx)("div",{className:"tile symbol symbol-"+t.symbol}),"Level ",i]})}}class E extends i.Component{render(){let e=this.props.progress;return e.winsToNextUnlock<=0?null:Object(d.jsxs)("div",{className:"rulesrow",children:[Object(d.jsx)("div",{className:"tile symbol symbol-lock"}),"Win ",e.winsToNextUnlock," more games on level ",e.maxDifficulty," to unlock"]})}}class L extends i.Component{render(){let e=this.props,t=(e.hideLevelSelect,e.setCurrentDifficulty),l=e.visible,i=e.progress;return Object(d.jsx)("div",{className:"modalpage "+(l?"visible":"hidden"),children:Object(d.jsxs)("div",{className:"contentbox",children:[Object(d.jsx)("h1",{children:"Select a level"}),i.tileTypes.map(((e,l)=>Object(d.jsx)(w,{selected:i.currentDifficulty===l+1,difficulty:l+1,tileSpec:e,setCurrentDifficulty:t},l))),Object(d.jsx)(E,{progress:i})]})})}}var z=Object(o.b)((e=>({progress:e.progress,visible:e.levelSelectShown})),(e=>({setCurrentDifficulty:t=>e((e=>({type:"SET_CURRENT_DIFFICULTY",val:e}))(t)),hideLevelSelect:t=>e((e=>({type:"HIDE_LEVEL_SELECT",id:e}))(t))})))(L);class C extends i.Component{componentDidMount(){let e=this.props,t=e.progress,l=e.loadProgress;t||l()}render(){return this.props.progress?Object(d.jsxs)("div",{className:"App",style:{},children:[Object(d.jsx)(x,{}),Object(d.jsx)(S,{}),Object(d.jsx)(T,{}),Object(d.jsx)(z,{})]}):null}}var D=Object(o.b)((e=>({progress:e.progress})),(e=>({loadProgress:t=>e((function(e){let t=localStorage.getItem("progress");e({type:"RECEIVE_PROGRESS",progress:t?JSON.parse(t):null})}))})))(C);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));var k=l(4),N=l(6),R=l(2);const I={blank:{validate:()=>!0},paired:{generateSubtype:e=>({tileType:"paired",groupSize:Math.floor(5*Math.random()+1),symbol:e}),place:(e,t,l)=>{console.log("placing paired tiles");let i=["black","white","orange","blue","green","purple","yellow"].map((e=>[Math.random(),e])).sort(((e,t)=>e[0]-t[0])).map((e=>e[1])),s=Math.min(i.length,Math.floor(Math.random()*(t.length-2)+2));for(let r=0;r<s;r++){let s=i[r],o=[...t.keys()].filter((i=>{let r=t[i];return!r.some((e=>"paired"===l[e].tileType&&l[e].color===s))&&!(r.filter((e=>"blank"===l[e].tileType)).length<e.groupSize)})),n=Math.min(o.length,Math.floor(Math.random()*(t.length-2)+2));for(let i=0;i<n;i++){if(0===o.length)continue;let i=Math.floor(Math.random()*o.length),r=o[i];o.splice(i,1);let n=t[r];for(let t=0;t<e.groupSize;t++){let t=n.filter((e=>"blank"===l[e].tileType)),i=l[t[Math.floor(Math.random()*t.length)]];i.tileType="paired",i.color=s,i.groupSize=e.groupSize,i.symbol=e.symbol}}}},validate:(e,t,l,i)=>{let s=l[e];return t.filter((e=>{let t=l[e];return s.tileType===t.tileType&&s.color===t.color})).length===s.groupSize}},sameColor:{place:(e,t,l)=>{console.log("placing sameColor tiles");let i=["black","white","orange","blue","green","purple","yellow"].map((e=>[Math.random(),e])).sort(((e,t)=>e[0]-t[0])).map((e=>e[1])),s=Math.min(i.length,Math.floor(Math.random()*(t.length-2)+2));console.log("placing sameColor tiles - "+s);let r=[...t.keys()];for(let o=0;o<s;o++){let s=Math.floor(Math.random()*r.length),n=r[s];r.splice(s,1);let a=t[n],c=Math.ceil(a.length/2),d=1,h=Math.floor(Math.random()*(c-d)+d);for(let t=0;t<h;t++){let t=l[a[Math.floor(Math.random()*a.length)]];"blank"===t.tileType&&(t.tileType="sameColor",t.color=i[o],t.symbol=e.symbol)}}},validate:(e,t,l,i)=>{let s=l[e],r=t.filter((t=>{if(t===e)return!1;let i=l[t];return s.tileType===i.tileType&&s.color!==i.color}));return r.length>0&&(console.log("failed on tile "+e),console.log(s),console.log(t),console.log(r),console.log(l[r[0]])),0===r.length}}},_=["tree","drop","square","circle","diamond","octagon","blob","sun","react"];function U(e,t){return t.filter(((t,l)=>!(t.vertices.length<2)&&(t.vertices[0]===e||t.vertices[1]===e))).map(((t,l)=>t.vertices[0]===e?t.vertices[1]:t.vertices[0]))}function V(e,t){let l=[];for(let i=0;i<t.length;i++){let s=e.indexOf(t[i].vertices[0]),r=e.indexOf(t[i].vertices[1]);s>=0&&r>=0&&1===Math.abs(r-s)&&l.push(i)}return l}function G(e,t,l,i,s,r){l.splice(l.indexOf(e),1),t.push(e);let o=s.filter(((t,i)=>{if(t.tiles.length<2)return!1;if(r.indexOf(i)>=0)return!1;let s;if(t.tiles[0]===e)s=t.tiles[1];else{if(t.tiles[1]!==e)return!1;s=t.tiles[0]}return!(l.indexOf(s)<0)})).map(((t,l)=>t.tiles[0]===e?t.tiles[1]:t.tiles[0]));var n,a=Object(N.a)(o);try{for(a.s();!(n=a.n()).done;){let e=n.value;l.indexOf(e)<0||G(e,t,l,i,s,r)}}catch(c){a.e(c)}finally{a.f()}}function W(e,t,l){let i=e.map(((e,t)=>t)),s=[];for(;i.length>0;){let r=[];G(i[0],r,i,e,t,l),s.push(r)}return s}function P(e,t,l,i){if("exit"===t[e[e.length-1]].vertexType){let t=V(e,l),s={path:e,length:e.length,regions:W(i,l,t),edges:t};return s.regions.length<4?null:s}let s=t[e[e.length-1]].neighbours.filter((t=>e.indexOf(t)<0));if(0===s.length)return null;let r,o=Math.random()>.5&&e.length>1;for(;!o&&!r;){let n=s[Math.floor(Math.random()*s.length)];if(r=P([...e,n],t,l,i),r)return r;o=Math.random()>.5&&e.length>1}return null}function H(e,t,l){console.log(l);let i={name:"Generated Level",levelId:Math.floor(1e7*Math.random()),difficulty:l.currentDifficulty,rows:e,cols:t,tiles:[],edges:[],vertices:[],path:[],completed:!1,won:!1};for(let a=0;a<=e;a++)for(let e=0;e<=t;e++){let t={x:e+1,y:a+1,vertexType:"standard"};i.vertices.push(t)}for(let a=0;a<=e;a++){for(let l=0;l<t;l++){let s={x1:l+1,y1:a+1,x2:l+2,y2:a+1,broken:!1,tiles:[],vertices:[a*(t+1)+l,a*(t+1)+l+1]};a>0&&s.tiles.push((a-1)*t+l),a<e&&s.tiles.push(a*t+l),i.edges.push(s)}if(a<e)for(let e=0;e<=t;e++){let l={x1:e+1,y1:a+1,x2:e+1,y2:a+2,broken:!1,tiles:[],vertices:[a*(t+1)+e,(a+1)*(t+1)+e]};e>0&&l.tiles.push(a*t+e-1),e<t&&l.tiles.push(a*t+e),i.edges.push(l)}}for(let a=0;a<e;a++)for(let e=0;e<t;e++){let t={tileType:"blank",x1:e+1,y1:a+1,x2:e+2,y2:a+2};i.tiles.push(t)}for(let a=0;a<i.vertices.length;a++)i.vertices[a].neighbours=U(a,i.edges);let s=[Math.floor((e+1)*(t+1)-t/2-1)];for(let a=0;a<s.length;a++)i.vertices[s[a]].vertexType="entry";let r=[Math.floor(t/2)];for(let a=0;a<r.length;a++)i.vertices[r[a]].vertexType="exit";let o=P([s[0]],i.vertices,i.edges,i.tiles);for(let a=0;a<o.regions.length;a++)for(let e=0;e<o.regions[a].length;e++)i.tiles[o.regions[a][e]].solutionRegion=a;let n=Math.floor(15*Math.random()+5);for(let a=0;a<n;a++){let e=Math.floor(Math.random()*i.edges.length);o.edges.indexOf(e)>=0||(console.log("breaking edge "+e),i.edges[e].broken=!0)}for(let a=0;a<l.tileTypes.length&&a<i.difficulty;a++){let e=l.tileTypes[a];I[e.tileType].place(e,o.regions,i.tiles,e)}return i.edgeState=i.edges.map((e=>({visited:!1}))),i.vertexState=i.vertices.map((e=>({visited:!1}))),i.tileState=i.tiles.map((e=>({valid:!0}))),i.regions=[i.tiles.map(((e,t)=>t))],i.vertexState[s[0]].visited=!0,i.path=[s[0]],i.solution=o,i.entries=s,i.exits=r,i}function F(e){let t=e.tileTypes.map((e=>e.symbol)),l=_.filter((e=>t.indexOf(e)<0)),i=l[Math.floor(Math.random()*l.length)],s=Object.keys(I).filter((e=>!!I[e].generateSubtype));return I[s[Math.floor(Math.random()*s.length)]].generateSubtype(i)}let A={tileTypes:[{tileType:"paired",groupSize:2,symbol:"diamond",description:"Must be matched with one other of the same color"},{tileType:"sameColor",symbol:"drop",description:"Must not share a region with one of a different color"}],currentDifficulty:2,maxDifficulty:2,winsToNextUnlock:1};const B={level:Object(R.a)({},H(6,6,A)),levelSelectShown:!1,rulesShown:!1};function J(e){localStorage.setItem("progress",JSON.stringify(e))}var X=l(12);const Y=Object(k.c)(((e=B,t)=>{switch(console.log(t.type),t.type){case"RECEIVE_PROGRESS":{let l=t.progress||A;return Object(R.a)(Object(R.a)({},e),{},{progress:l,level:Object(R.a)({},H(6,6,l))})}case"UPDATE_TILE_DESCRIPTION":{console.log(t);let l=Object(R.a)(Object(R.a)({},e.progress),{},{tileTypes:[...e.progress.tileTypes]});return l.tileTypes[t.id]=Object(R.a)(Object(R.a)({},l.tileTypes[t.id]),{},{description:t.description}),J(l),Object(R.a)(Object(R.a)({},e),{},{progress:l})}case"SHOW_LEVEL_SELECT":return Object(R.a)(Object(R.a)({},e),{},{levelSelectShown:!0});case"HIDE_LEVEL_SELECT":return Object(R.a)(Object(R.a)({},e),{},{levelSelectShown:!1});case"SHOW_RULES":return Object(R.a)(Object(R.a)({},e),{},{rulesShown:!0});case"HIDE_RULES":return Object(R.a)(Object(R.a)({},e),{},{rulesShown:!1});case"SET_CURRENT_DIFFICULTY":{if(t.val===e.progress.currentDifficulty)return Object(R.a)(Object(R.a)({},e),{},{levelSelectShown:!1});let l=Object(R.a)(Object(R.a)({},e.progress),{},{currentDifficulty:t.val});return Object(R.a)(Object(R.a)({},e),{},{progress:l,level:Object(R.a)(Object(R.a)({},e.level),H(6,6,l)),levelSelectShown:!1})}case"NEW_GAME":return Object(R.a)(Object(R.a)({},e),{},{level:Object(R.a)(Object(R.a)({},e.level),H(6,6,e.progress))});case"RESET_LEVEL":return Object(R.a)(Object(R.a)({},e),{},{level:Object(R.a)(Object(R.a)({},e.level),{},{edgeState:e.level.edges.map((e=>({visited:!1}))),vertexState:e.level.vertices.map(((t,l)=>({visited:l===e.level.entries[0]}))),tileState:e.level.tiles.map((e=>({valid:!0}))),regions:[e.level.tiles.map(((e,t)=>t))],path:[e.level.entries[0]],completed:!1,won:!1})});case"VISIT_VERTEX":{console.log(t.type),console.log(t.id);let r=t.id,o=[...e.level.vertexState];o[r]=Object(R.a)({},o[r]);let n=e.level.vertices[r],a=[...e.level.path],c=!1,d=!1;if(!n)return e;if(e.level.completed)return e;let h=a[a.length-1],p=a[a.length-2],v=e.level.edges.findIndex((e=>e.vertices.indexOf(r)>=0&&e.vertices.indexOf(h)>=0&&!e.broken)),g=e.level.edges[v];if(console.log("Found edge "+v),console.log(g),0===a.length&&"entry"!==n.vertexType)return e;if(1===a.length&&"entry"===n.vertexType)a=[r],o=e.level.vertices.map((e=>({visited:!1}))),o[r].visited=!0;else if("entry"!==n.vertexType||g)if(r===p)o[a.pop()]={visited:!1};else{if(o[r].visited)return e;if(a.length>0&&!g)return e;o[r].visited=!0,a.push(r),"exit"===n.vertexType&&(c=!0)}else a=[r],o=e.level.vertices.map((e=>({visited:!1}))),o[r].visited=!0;let u=V(a,e.level.edges),b=e.level.edgeState.map(((e,t)=>u.indexOf(t)>=0?{visited:!0}:{visited:!1})),f=W(e.level.tiles,e.level.edges,u);d=!0;let m=e.level.tiles.map(((t,l)=>Object(R.a)(Object(R.a)({},e.level.tileState[l]),{},{valid:!0})));for(let t=0;t<f.length;t++){var l,i=Object(N.a)(f[t]);try{for(i.s();!(l=i.n()).done;){let i=l.value;m[i].region=t;let s=I[e.level.tiles[i].tileType].validate(i,f[t],e.level.tiles,m);s||(d=!1),m[i].valid=s}}catch(s){i.e(s)}finally{i.f()}}let j=Object(R.a)(Object(R.a)({},e),{},{level:Object(R.a)(Object(R.a)({},e.level),{},{vertexState:o,edgeState:b,tileState:m,path:a,completed:c,won:d,regions:f})});if(d&&c&&e.level.difficulty===e.progress.maxDifficulty){let t=j.progress=Object(R.a)({},e.progress);t.winsToNextUnlock--,t.winsToNextUnlock<=0&&t.tileTypes.length<_.length-1&&(t.winsToNextUnlock=10,t.maxDifficulty++,t.currentDifficulty++,t.tileTypes=[...t.tileTypes,F(t)],J(t))}return j}default:return e}}),Object(k.a)(X.a));r.a.render(Object(d.jsx)(o.a,{store:Y,children:Object(d.jsx)(D,{})}),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((e=>{e.unregister()}))}},[[26,1,2]]]);
//# sourceMappingURL=main.5c61063b.chunk.js.map