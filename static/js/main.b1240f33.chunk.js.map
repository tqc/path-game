{"version":3,"sources":["actions.js","TileView.js","EdgeView.js","VertexView.js","GameBoard.js","GameContainer.js","App.js","serviceWorker.js","store.js","index.js"],"names":["newGame","text","type","visitVertex","id","resetLevel","TileView","_this$props","this","props","tile","tileState","tileSize","edgeSize","react_default","a","createElement","className","tileType","valid","style","width","height","left","x1","top","y1","color","Component","EdgeView","edge","edgeState","x2","visited","broken","VertexView","vertex","vertexState","vertexType","x","y","GameBoard","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","onMouseDown","bind","assertThisInitialized","onMouseMove","onMouseUp","state","dragging","e","level","nativeEvent","clientX","div","offsetLeft","clientY","offsetTop","col","Math","round","row","console","log","rows","cols","_this$props2","_this2","tiles","overlay","completed","won","ref","map","t","i","src_TileView","key","edges","src_EdgeView","edgeId","vertices","v","src_VertexView","vertexId","connect","dispatch","Actions","GameContainer","_this$state","prevLevel","nextLevel","onClick","src_GameBoard","levelId","setTimeout","App","src_GameContainer","Boolean","window","location","hostname","match","tileTypes","blank","validate","sameColor","place","regions","availableColors","colorCount","min","length","floor","random","unclaimedRegions","toConsumableArray","keys","ri","regionId","splice","region","maxInRegion","ceil","countInRegion","j","tileId","conflicts","filter","otherTile","neighbouringVertices","getVisitedEdges","path","visitedEdges","pi1","indexOf","pi2","abs","push","expandRegion","startTile","unmatchedTiles","neighbours","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","err","return","calculateRegions","generateLevel","name","topEdge","y2","leftEdge","entries","exits","solution","randomPath","nextPoints","foundSolution","shouldBacktrack","nextVertexId","concat","solutionRegion","breaks","_arr","_i7","initialState","objectSpread","reducer","combineReducers","arguments","action","lastVertexId","backtrackVertexId","findIndex","pop","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","tv","store","createStore","ReactDOM","render","es","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b1240f33.chunk.js","sourcesContent":["export const newGame = text => ({\n    type: 'NEW_GAME',\n    text\n});\n\nexport const visitVertex = id => ({\n    type: 'VISIT_VERTEX',\n    id\n});\n\nexport const resetLevel = id => ({\n    type: 'RESET_LEVEL',\n    id\n});","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass TileView extends Component {\n    render() {\n        let {tile, tileState, tileSize, edgeSize} = this.props;\n        return (\n            <div className={'tile ' + (tile.tileType || \"\") + (tileState.valid ? \" valid\" : \" invalid\")} style={{\n                width: tileSize,\n                height: tileSize,\n                left: (tile.x1 * (tileSize + edgeSize)),\n                top: (tile.y1 * (tileSize + edgeSize)),\n                color: tile.color || \"black\"\n            }}>\n            </div>\n        );\n    }\n}\n\nTileView.propTypes = {\n    tile: PropTypes.shape({\n        tileType: PropTypes.string.isRequired,\n        x1: PropTypes.number.isRequired,\n        y1: PropTypes.number.isRequired,\n    }).isRequired,\n    tileState: PropTypes.shape({\n        valid: PropTypes.bool.isRequired,\n    }).isRequired,\n    tileSize: PropTypes.number.isRequired,\n    edgeSize: PropTypes.number.isRequired,\n};\n\n\nexport default TileView;","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass EdgeView extends Component {\n    render() {\n        let {edge, edgeState, tileSize, edgeSize} = this.props;\n        if (edge.x1 === edge.x2) {\n            // vertical\n            return (\n                <div className={\"edge vertical\" + (edgeState.visited ? \" visited\" : \"\") + (edge.broken ? \" broken\" : \"\")} style={{\n                    width: edgeSize,\n                    height: tileSize,\n                    left: (edge.x1 * (tileSize + edgeSize) - edgeSize),\n                    top: (edge.y1 * (tileSize + edgeSize))\n                }}>\n                </div>\n            );\n        }\n        else {\n            return (\n                <div className={\"edge horizontal\" + (edgeState.visited ? \" visited\" : \"\") + (edge.broken ? \" broken\" : \"\")} style={{\n                    width: tileSize,\n                    height: edgeSize,\n                    left: (edge.x1 * (tileSize + edgeSize)),\n                    top: (edge.y1 * (tileSize + edgeSize) - edgeSize)\n                }}>\n                </div>\n            );\n        }\n    }\n}\n\nEdgeView.propTypes = {\n    edge: PropTypes.shape({\n        x1: PropTypes.number.isRequired,\n        y1: PropTypes.number.isRequired,\n        broken: PropTypes.bool.isRequired,\n    }).isRequired,\n    tileSize: PropTypes.number.isRequired,\n    edgeSize: PropTypes.number.isRequired,\n    edgeState: PropTypes.shape({\n        visited: PropTypes.bool.isRequired\n    }).isRequired\n};\n\nexport default EdgeView;","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass VertexView extends Component {\n    render() {\n        let {vertex, vertexState, tileSize, edgeSize} = this.props;\n        if (vertex.vertexType === \"entry\") {\n            return (\n                <div className={'vertex ' + (vertex.vertexType || \"\") + (vertexState.visited ? \" visited\" : \"\")} style={{\n                    width: edgeSize * 3,\n                    height: edgeSize * 3,\n                    left: (vertex.x * (tileSize + edgeSize) - edgeSize - edgeSize),\n                    top: (vertex.y * (tileSize + edgeSize) - edgeSize - edgeSize)\n                }}>\n                </div>\n            );\n        }\n        else if (vertex.vertexType === \"exit\") {\n            return (\n                <div className={'vertex ' + (vertex.vertexType || \"\") + (vertexState.visited ? \" visited\" : \"\")} style={{\n                    width: edgeSize * 3,\n                    height: edgeSize * 3,\n                    left: (vertex.x * (tileSize + edgeSize) - edgeSize - edgeSize),\n                    top: (vertex.y * (tileSize + edgeSize) - edgeSize - edgeSize)\n                }}>\n                </div>\n            );\n        }\n        else {\n            return (\n                <div className={'vertex ' + (vertex.vertexType || \"\") + (vertexState.visited ? \" visited\" : \"\")} style={{\n                    width: edgeSize,\n                    height: edgeSize,\n                    left: (vertex.x * (tileSize + edgeSize) - edgeSize),\n                    top: (vertex.y * (tileSize + edgeSize) - edgeSize)\n                }}>\n\n                </div>\n            );\n        }\n\n    }\n}\n\nVertexView.propTypes = {\n    vertex: PropTypes.shape({\n        vertexType: PropTypes.string.isRequired,\n        x1: PropTypes.number.isRequired,\n        y1: PropTypes.number.isRequired,\n        x2: PropTypes.number.isRequired,\n        y2: PropTypes.number.isRequired,\n    }).isRequired,\n    tileSize: PropTypes.number.isRequired,\n    edgeSize: PropTypes.number.isRequired,\n    vertexState: PropTypes.shape({\n        visited: PropTypes.bool.isRequired\n    }).isRequired\n};\n\nexport default VertexView;","import { connect } from 'react-redux';\nimport * as Actions from './actions';\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport TileView from './TileView';\nimport EdgeView from './EdgeView';\nimport VertexView from './VertexView';\n\nclass GameBoard extends Component {\n    constructor() {\n        super();\n        this.onMouseDown = this.onMouseDown.bind(this);\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.onMouseUp = this.onMouseUp.bind(this);\n        this.state = {};\n        this.dragging = false;\n    }\n    onMouseDown(e) {\n        this.dragging = true;\n    }\n    onMouseMove(e) {\n        if (!this.dragging) return;\n        let {level, visitVertex} = this.props;\n        let x = (e.nativeEvent.clientX - this.div.offsetLeft);\n        let y = (e.nativeEvent.clientY - this.div.offsetTop);\n\n        // find nearest vertex\n\n        let col = Math.round(x / 60) - 1;\n        let row = Math.round(y / 60) - 1;\n        console.log(x + \", \" + y + \" => \" + col + \", \" + row);\n\n        if (col >= 0 && row >= 0 && row <= level.rows && col <= level.cols) {\n            let vertexId = row * (level.cols + 1) + col;\n            visitVertex(vertexId);\n        }\n    }\n    onMouseUp(e) {\n        if (!this.dragging) return;\n        this.dragging = false;\n        let {level, visitVertex} = this.props;\n        let x = (e.nativeEvent.clientX - this.div.offsetLeft);\n        let y = (e.nativeEvent.clientY - this.div.offsetTop);\n\n        // find nearest vertex\n\n        let col = Math.round(x / 60) - 1;\n        let row = Math.round(y / 60) - 1;\n        console.log(x + \", \" + y + \" => \" + col + \", \" + row);\n\n        if (col >= 0 && row >= 0 && row <= level.rows && col <= level.cols) {\n            let vertexId = row * (level.cols + 1) + col;\n            visitVertex(vertexId);\n        }\n    }\n    render() {\n        let {level} = this.props;\n        if (!level || !level.tiles || !level.tiles[0]) {\n            return (\n                <div className=\"board\">\n          No game loaded;\n                </div>\n            );\n        }\n        else {\n            let overlay = null;\n            if (level.completed && !level.won) {\n                overlay = (\n                    <div className=\"boardOverlay\">\n\n                    </div>\n                );\n            }\n            else if (level.completed && level.won) {\n                overlay = (\n                    <div className=\"boardOverlay\">\n\n                    </div>\n                );\n            }\n            return (\n                <div\n                    className={\"board \" + (level.completed ? \" completed\" : \"\") + (level.won ? \" won\" : \"\") }\n                    ref={e => (this.div = e)}\n                    onMouseDown={this.onMouseDown}\n                    onMouseMove={this.onMouseMove}\n                    onMouseUp={this.onMouseUp}\n                >\n                    {level.tiles.map((t, i) => (<TileView\n                        key={i}\n                        tile={t}\n                        tileState={level.tileState[i]}\n                        tileSize={50}\n                        edgeSize={10} />))}\n                    {level.edges.map((e, i) => (<EdgeView\n                        key={i}\n                        edge={e}\n                        edgeId={i}\n                        edgeState={level.edgeState[i]}\n                        tileSize={50}\n                        edgeSize={10} />))}\n                    {level.vertices.map((v, i) => (<VertexView\n                        key={i}\n                        vertex={v}\n                        vertexId={i}\n                        vertexState={level.vertexState[i]}\n                        tileSize={50}\n                        edgeSize={10} />))}\n                    {overlay}\n                </div>\n            );\n        }\n    }\n}\n\nGameBoard.propTypes = {\n    level: PropTypes.shape({\n\n    }).isRequired,\n    resetLevel: PropTypes.func.isRequired,\n    newGame: PropTypes.func.isRequired,\n    visitVertex: PropTypes.func.isRequired,\n};\n\nexport default connect(\n    state => ({\n        // level: state.level,\n    }),\n    dispatch => ({\n        resetLevel: id => dispatch(Actions.resetLevel(id)),\n        newGame: id => dispatch(Actions.newGame(id)),\n        visitVertex: id => dispatch(Actions.visitVertex(id))\n    })\n)(GameBoard);","import { connect } from 'react-redux';\nimport * as Actions from './actions';\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport GameBoard from './GameBoard';\n\nclass GameContainer extends Component {\n    constructor() {\n        super();\n        this.state = {};\n    }\n\n    static getDerivedStateFromProps(props, state) {\n        if (!state.level || !props.level) {\n            return {\n                nextLevel: null,\n                level: props.level,\n                prevLevel: null\n            };\n        }\n\n        if (state.level && props.level && state.level.levelId !== props.level.levelId) {\n            // resetting to new level\n            console.log(\"resetting\");\n            return {\n                nextLevel: props.level,\n                level: null,\n                prevLevel: state.level\n            };\n        }\n\n        if (!state.level.completed && props.level.completed) {\n            if (props.level.won) {\n                setTimeout(() => props.newGame(), 500);\n            }\n            else {\n                setTimeout(() => props.resetLevel(), 1000);\n            }\n        }\n\n        return {\n            nextLevel: null,\n            level: props.level,\n            prevLevel: null\n        };\n    }\n\n    render() {\n        let {level, prevLevel, nextLevel} = this.state;\n\n        return (\n            <div className=\"boardcontainer\" ref={e => (this.div = e)} onClick={this.onClick}>\n                {(prevLevel ? (<div className=\"prevLevel\"><GameBoard level={prevLevel} /></div>) : null)}\n                {(level ? (<div className=\"currentLevel\"><GameBoard level={level} /></div>) : null)}\n                {(nextLevel ? (<div className=\"nextLevel\"><GameBoard level={nextLevel} /></div>) : null)}\n\n            </div>\n        );\n\n    }\n}\n\nGameContainer.propTypes = {\n    level: PropTypes.shape({\n    }),\n};\n\nexport default connect(\n    state => ({\n        level: state.level,\n    }),\n    dispatch => ({\n        resetLevel: id => dispatch(Actions.resetLevel(id)),\n        newGame: id => dispatch(Actions.newGame(id)),\n        visitVertex: id => dispatch(Actions.visitVertex(id))\n    })\n)(GameContainer);","import React, { Component } from 'react';\nimport './App.css';\nimport GameContainer from './GameContainer';\n\nclass App extends Component {\n    render() {\n        return (\n            <div className=\"App\">\n                <GameContainer />\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then(response => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (\n                response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\n                'No internet connection found. App is running in offline mode.'\n            );\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import { combineReducers } from 'redux';\n\n\nconst tileTypes = {\n    blank: {\n        validate: () => true\n    },\n    sameColor: {\n        place: (regions, tiles) => {\n            console.log(\"placing sameColor tiles\");\n            // at least two colors, up to the number of regions\n            let availableColors = [\"black\", \"white\", \"red\", \"blue\", \"green\"];\n            let colorCount = Math.min(availableColors.length, Math.floor(Math.random() * (regions.length - 2) + 2));\n\n            console.log(\"placing sameColor tiles - \" + colorCount);\n\n            let unclaimedRegions = [...regions.keys()];\n            for (let i = 0; i < colorCount; i++) {\n                let ri = Math.floor(Math.random() * unclaimedRegions.length);\n                let regionId = unclaimedRegions[ri];\n                unclaimedRegions.splice(ri, 1);\n                let region = regions[regionId];\n                let maxInRegion = Math.ceil(region.length / 2);\n                let minInRegion = 1;\n                let countInRegion = Math.floor(Math.random() * (maxInRegion - minInRegion) + minInRegion);\n                for (let j = 0; j < countInRegion; j++) {\n                    let tile = tiles[region[Math.floor(Math.random() * region.length)]];\n                    if (tile.tileType !== \"blank\") continue;\n                    tile.tileType = \"sameColor\";\n                    tile.color = availableColors[i];\n                }\n\n            }\n\n        },\n        validate: (tileId, region, tiles, tileState) => {\n            let tile = tiles[tileId];\n            let conflicts = region.filter(id => {\n                if (id === tileId) return false;\n                let otherTile = tiles[id];\n                if (tile.tileType === otherTile.tileType && tile.color !== otherTile.color) {\n                    return true;\n                }\n                return false;\n            });\n            if (conflicts.length > 0) {\n                console.log(\"failed on tile \" + tileId);\n                console.log(tile);\n                console.log(region);\n                console.log(conflicts);\n                console.log(tiles[conflicts[0]]);\n\n            }\n            return conflicts.length === 0;\n        }\n    }\n};\n\nfunction neighbouringVertices(vertexId, edges) {\n    return edges.filter((e, i) => {\n        if (e.vertices.length < 2) return false;\n        if (e.vertices[0] === vertexId || e.vertices[1] === vertexId) return true;\n        else return false;\n    }).map((e, i) => {\n        if (e.vertices[0] === vertexId) return e.vertices[1];\n        else return e.vertices[0];\n    });\n}\n\nfunction getVisitedEdges(path, edges) {\n    let visitedEdges = [];\n    for (let i = 0; i < edges.length; i++) {\n        let pi1 = path.indexOf(edges[i].vertices[0]);\n        let pi2 = path.indexOf(edges[i].vertices[1]);\n        if (pi1 >= 0 && pi2 >= 0 && Math.abs(pi2 - pi1) === 1) {\n            visitedEdges.push(i);\n        }\n    }\n    return visitedEdges;\n}\n\n\nfunction expandRegion(startTile, region, unmatchedTiles, tiles, edges, visitedEdges) {\n    unmatchedTiles.splice(unmatchedTiles.indexOf(startTile), 1);\n    region.push(startTile);\n    let neighbours = edges.filter((e, i) => {\n        if (e.tiles.length < 2) return false;\n        if (visitedEdges.indexOf(i) >= 0) return false;\n        let otherTile;\n        if (e.tiles[0] === startTile) otherTile = e.tiles[1];\n        else if (e.tiles[1] === startTile) otherTile = e.tiles[0];\n        else return false;\n        if (unmatchedTiles.indexOf(otherTile) < 0) return false;\n        return true;\n    }).map((e, i) => {\n        if (e.tiles[0] === startTile) return e.tiles[1];\n        else return e.tiles[0];\n    });\n    for (let t of neighbours) {\n    // tile may have matched since the filtering step\n        if (unmatchedTiles.indexOf(t) < 0) continue;\n        expandRegion(t, region, unmatchedTiles, tiles, edges, visitedEdges);\n    }\n}\n\nfunction calculateRegions(tiles, edges, visitedEdges) {\n    let unmatchedTiles = tiles.map((e, i) => i);\n    let regions = [];\n    while (unmatchedTiles.length > 0) {\n        let region = [];\n        expandRegion(unmatchedTiles[0], region, unmatchedTiles, tiles, edges, visitedEdges);\n        regions.push(region);\n    }\n\n    return regions;\n}\n\n\nfunction randomPath(path, vertices, edges, tiles) {\n    if (vertices[path[path.length - 1]].vertexType === \"exit\") {\n    // this may be a valid solution\n        let visitedEdges = getVisitedEdges(path, edges);\n\n        let solution = {\n            path: path,\n            length: path.length,\n            regions: calculateRegions(tiles, edges, visitedEdges),\n            edges: visitedEdges\n\n        };\n        if (solution.regions.length < 4) return null;\n        return solution;\n    }\n\n    // otherwise, see if a random edge leads to a solution\n\n    // all unvisited neighbours\n    let nextPoints = vertices[path[path.length - 1]].neighbours.filter(v => path.indexOf(v) < 0);\n    if (nextPoints.length === 0) {\n    // dead end\n        return null;\n    }\n    let shouldBacktrack = Math.random() > 0.5 && path.length > 1;\n    let foundSolution;\n\n    while (!shouldBacktrack && !foundSolution) {\n        let nextVertexId = nextPoints[Math.floor(Math.random() * nextPoints.length)];\n        let newPath = [...path, nextVertexId];\n        foundSolution = randomPath(newPath, vertices, edges, tiles);\n        if (foundSolution) return foundSolution;\n        shouldBacktrack = Math.random() > 0.5 && path.length > 1;\n    }\n    return null;\n}\n\n\nfunction generateLevel(rows, cols) {\n    let level = {\n        name: \"Generated Level\",\n        levelId: Math.floor(Math.random() * 10000000),\n        rows: rows,\n        cols: cols,\n        // 8x8\n        tiles: [],\n        // 8h, 9v\n        edges: [],\n        // 9x9\n        vertices: [],\n        path: [],\n        completed: false,\n        won: false,\n    };\n\n    for (let i = 0; i <= rows; i++) {\n        for (let j = 0; j <= cols; j++) {\n            let vertex = {\n                x: j + 1,\n                y: i + 1,\n            };\n            level.vertices.push(vertex);\n        }\n    }\n\n    for (let row = 0; row <= rows; row++) {\n    // add top edge\n        for (let col = 0; col < cols; col++) {\n            let topEdge = {\n                x1: col + 1,\n                y1: row + 1,\n                x2: col + 2,\n                y2: row + 1,\n                broken: false,\n                tiles: [],\n                vertices: [\n                    (row) * (cols + 1) + col,\n                    (row) * (cols + 1) + col + 1]\n            };\n            if (row > 0) {\n                topEdge.tiles.push((row - 1) * cols + col);\n            }\n            if (row < rows) {\n                topEdge.tiles.push((row) * cols + col);\n            }\n            level.edges.push(topEdge);\n        }\n\n        // add left side if not below last row\n        if (row < rows) {\n            for (let col = 0; col <= cols; col++) {\n                let leftEdge = {\n                    x1: col + 1,\n                    y1: row + 1,\n                    x2: col + 1,\n                    y2: row + 2,\n                    broken: false,\n                    tiles: [],\n                    vertices: [\n                        (row) * (cols + 1) + col,\n                        (row + 1) * (cols + 1) + col]\n                };\n                if (col > 0) {\n                    leftEdge.tiles.push((row) * cols + col - 1);\n                }\n                if (col < cols) {\n                    leftEdge.tiles.push((row) * cols + col);\n                }\n                level.edges.push(leftEdge);\n            }\n        }\n    }\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            let tile = {\n                tileType: \"blank\",\n                x1: j + 1,\n                y1: i + 1,\n                x2: j + 2,\n                y2: i + 2\n            };\n            level.tiles.push(tile);\n        }\n    }\n\n\n    for (let i = 0; i < level.vertices.length; i++) {\n        level.vertices[i].neighbours = neighbouringVertices(i, level.edges);\n    }\n\n\n    // add an entry\n    let entries = [(rows + 1) * (cols + 1) - 5];\n\n    for (let i = 0; i < entries.length; i++) {\n        level.vertices[entries[i]].vertexType = \"entry\";\n    }\n\n\n    // add an exit\n    let exits = [4];\n\n    for (let i = 0; i < exits.length; i++) {\n        level.vertices[exits[i]].vertexType = \"exit\";\n    }\n\n\n    // let solutions = [];\n\n\n    //  for (let i = 0; i < entries.length; i++) {\n    //    extendPath([entries[i]], level.vertices, level.edges, solutions)\n    //  }\n\n    let solution = randomPath([entries[0]], level.vertices, level.edges, level.tiles);\n\n    for (let i = 0; i < solution.regions.length; i++) {\n        for (let j = 0; j < solution.regions[i].length; j++) {\n            level.tiles[solution.regions[i][j]].solutionRegion = i;\n        }\n    }\n\n    let minBreaks = 5;\n    let maxBreaks = 20;\n    let breaks = Math.floor(Math.random() * (maxBreaks - minBreaks) + minBreaks);\n    // add random broken edges\n    for (let i = 0; i < breaks; i++) {\n        let edgeId = Math.floor(Math.random() * level.edges.length);\n        if (solution.edges.indexOf(edgeId) >= 0) continue;\n        console.log(\"breaking edge \" + edgeId);\n        level.edges[edgeId].broken = true;\n    }\n\n    // add tiles\n\n    for (let tileType of [\"sameColor\"]) {\n        tileTypes[tileType].place(solution.regions, level.tiles);\n    }\n\n    level.edgeState = level.edges.map(e => ({\n        visited: false\n    }));\n\n    level.vertexState = level.vertices.map(e => ({\n        visited: false\n    }));\n\n    level.tileState = level.tiles.map(e => ({\n        valid: true\n    }));\n\n    level.regions = [level.tiles.map((e, i) => (i))];\n\n    // for testing\n\n    level.vertexState[entries[0]].visited = true;\n    level.path = [entries[0]];\n\n\n    return level;\n}\n\n\nexport const initialState = {\n    level: {\n        ...generateLevel(8, 8),\n    }\n};\n\nconst level = (state = initialState.level, action) => {\n    console.log(action.type);\n\n    switch (action.type) {\n    case 'NEW_GAME':\n        return {\n            ...state,\n            ...generateLevel(8, 8)\n        };\n    case 'RESET_LEVEL':\n        return {\n            ...state,\n            edgeState: state.edges.map(e => ({\n                visited: false\n            })),\n\n            vertexState: state.vertices.map(e => ({\n                visited: false\n            })),\n\n            tileState: state.tiles.map(e => ({\n                valid: true\n            })),\n\n            regions: [state.tiles.map((e, i) => (i))],\n\n            path: [],\n\n            completed: false,\n\n            won: false,\n\n        };\n    case 'VISIT_VERTEX': {\n        console.log(action.type);\n        console.log(action.id);\n        let vertexId = action.id;\n        let vertexState = [...state.vertexState];\n        vertexState[vertexId] = {...vertexState[vertexId]};\n        let vertex = state.vertices[vertexId];\n        let path = [...state.path];\n        let completed = false;\n        let won = false;\n\n        if (!vertex) return state;\n        // no need to keep going once completed\n        if (state.completed) return state;\n\n        let lastVertexId = path[path.length - 1];\n        let backtrackVertexId = path[path.length - 2];\n\n        let edgeId = state.edges.findIndex(e => {\n            return e.vertices.indexOf(vertexId) >= 0\n          && e.vertices.indexOf(lastVertexId) >= 0\n          && !e.broken;\n        });\n        let edge = state.edges[edgeId];\n        console.log(\"Found edge \" + edgeId);\n        console.log(edge);\n\n        // if path is empty, must visit a start point\n        if (path.length === 0 && vertex.vertexType !== \"entry\") {\n            return state;\n        }\n        // if path has only entry point, visiting another entry starts a new path\n        else if (path.length === 1 && vertex.vertexType === \"entry\") {\n            path = [vertexId];\n            vertexState = state.vertices.map(e => ({\n                visited: false\n            }));\n            vertexState[vertexId].visited = true;\n        }\n        // restart level by visiting entry point when not on a neighbouring vertex\n        else if (vertex.vertexType === \"entry\" && !edge) {\n            path = [vertexId];\n            vertexState = state.vertices.map(e => ({\n                visited: false\n            }));\n            vertexState[vertexId].visited = true;\n        }\n        // backtrack\n        else if (vertexId === backtrackVertexId) {\n            vertexState[path.pop()] = {\n                visited: false\n            };\n        }\n        else if (vertexState[vertexId].visited) {\n        // can't visit twice\n            return state;\n        }\n        else if (path.length > 0 && !edge) {\n        // no valid edge\n            return state;\n        }\n        else {\n        // visiting a new vertex\n            vertexState[vertexId].visited = true;\n            path.push(vertexId);\n            if (vertex.vertexType === \"exit\") {\n                // level completed - check if won\n                completed = true;\n            }\n\n        }\n\n\n\n        let visitedEdges = getVisitedEdges(path, state.edges);\n        let edgeState = state.edgeState.map((e, i) => {\n            if (visitedEdges.indexOf(i) >= 0) {\n                return {\n                    visited: true\n                };\n            }\n            else {\n                return {\n                    visited: false\n                };\n            }\n        });\n\n        let regions = calculateRegions(state.tiles, state.edges, visitedEdges);\n        //console.log(\"Current regions: \")\n        //console.log(regions);\n        // now validate the regions against the rules for each file\n        won = true;\n\n        let tileState = state.tiles.map((t, i) => {\n            return {\n                ...state.tileState[i],\n                valid: true\n            };\n        });\n\n        for (let i = 0; i < regions.length; i++) {\n        // validate each region's tiles. if any is invalid, mutate tileState and set won to false;\n            for (let t of regions[i]) {\n                tileState[t].region = i;\n                let tv = tileTypes[state.tiles[t].tileType].validate(t, regions[i], state.tiles, tileState);\n                if (!tv) won = false;\n                tileState[t].valid = tv;\n            }\n        }\n\n\n        let newState = {\n            ...state,\n            vertexState,\n            edgeState,\n            tileState,\n            path,\n            completed,\n            won,\n            regions\n        };\n        return newState;\n    }\n    default:\n        return state;\n    }\n};\n\nexport const reducer = combineReducers({\n    level\n});\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\nimport { reducer } from './store';\n\nconst store = createStore(reducer);\n\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}