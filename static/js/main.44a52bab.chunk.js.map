{"version":3,"sources":["logo.svg","store.js","TileView.js","EdgeView.js","VertexView.js","GameBoard.js","GameContainer.js","GameMenu.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","nextTodoId","newGame","text","type","id","visitVertex","resetLevel","tileTypes","blank","validate","sameColor","place","regions","tiles","console","log","availableColors","colorCount","Math","min","length","floor","random","unclaimedRegions","Object","toConsumableArray","keys","i","ri","regionId","splice","region","maxInRegion","ceil","countInRegion","j","tile","tileType","color","tileId","tileState","conflicts","filter","otherTile","neighbouringVertices","vertexId","edges","e","vertices","map","getVisitedEdges","path","visitedEdges","pi1","indexOf","pi2","abs","push","generateLevel","rows","cols","level","name","levelId","completed","won","vertex","x","y","row","col","topEdge","x1","y1","x2","y2","broken","leftEdge","neighbours","entries","vertexType","exits","solution","randomPath","calculateRegions","nextPoints","v","foundSolution","shouldBacktrack","nextVertexId","concat","solutionRegion","breaks","edgeId","_arr","_i7","edgeState","visited","vertexState","valid","expandRegion","startTile","unmatchedTiles","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","t","value","err","return","initialState","objectSpread","reducer","combineReducers","state","arguments","action","lastVertexId","backtrackVertexId","findIndex","edge","pop","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","tv","todo","TileView","_this$props","this","props","tileSize","edgeSize","react_default","a","createElement","className","style","width","height","left","top","Component","EdgeView","VertexView","GameBoard","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","onClick","bind","assertThisInitialized","nativeEvent","clientX","div","offsetLeft","clientY","offsetTop","round","_this2","overlay","ref","src_TileView","src_EdgeView","src_VertexView","connect","dispatch","GameContainer","_this$state","prevLevel","nextLevel","src_GameBoard","setTimeout","GameMenu","App","src_GameContainer","src_GameMenu","Boolean","window","location","hostname","match","store","createStore","ReactDOM","render","es","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"qIAAAA,EAAAC,QAAiBC,EAAAC,EAAuB,yNCGpCC,EAAa,EACJC,EAAU,SAAAC,GAAI,MAAK,CAC9BC,KAAM,WACNC,GAAIJ,IACJE,SAGWG,EAAc,SAAAD,GAAE,MAAK,CAChCD,KAAM,eACNC,OAGWE,EAAa,SAAAF,GAAE,MAAK,CAC/BD,KAAM,cACNC,OAGIG,EAAY,CAChBC,MAAO,CACLC,SAAU,kBAAM,IAElBC,UAAW,CACTC,MAAO,SAACC,EAASC,GACfC,QAAQC,IAAI,2BAEZ,IAAIC,EAAkB,CAAC,QAAS,QAAS,MAAO,OAAQ,SACpDC,EAAaC,KAAKC,IAAIH,EAAgBI,OAAQF,KAAKG,MAAMH,KAAKI,UAAYV,EAAQQ,OAAO,GAAK,IAElGN,QAAQC,IAAI,6BAA+BE,GAG3C,IADA,IAAIM,EAAgBC,OAAAC,EAAA,EAAAD,CAAOZ,EAAQc,QAC1BC,EAAI,EAAGA,EAAIV,EAAYU,IAAK,CACnC,IAAIC,EAAKV,KAAKG,MAAMH,KAAKI,SAASC,EAAiBH,QAC/CS,EAAWN,EAAiBK,GAChCL,EAAiBO,OAAOF,EAAI,GAK5B,IAJA,IAAIG,EAASnB,EAAQiB,GACjBG,EAAcd,KAAKe,KAAKF,EAAOX,OAAO,GAEtCc,EAAgBhB,KAAKG,MAAMH,KAAKI,UAAUU,EAD5B,MAETG,EAAI,EAAGA,EAAID,EAAeC,IAAK,CACtC,IAAIC,EAAOvB,EAAMkB,EAAOb,KAAKG,MAAMH,KAAKI,SAASS,EAAOX,UACnC,SAAjBgB,EAAKC,WACTD,EAAKC,SAAW,YAChBD,EAAKE,MAAQtB,EAAgBW,OAMnClB,SAAU,SAAC8B,EAAQR,EAAQlB,EAAO2B,GAChC,IAAIJ,EAAOvB,EAAM0B,GACbE,EAAYV,EAAOW,OAAO,SAAAtC,GAC5B,GAAIA,GAAMmC,EAAQ,OAAO,EACzB,IAAII,EAAY9B,EAAMT,GACtB,OAAIgC,EAAKC,UAAYM,EAAUN,UAAYD,EAAKE,OAASK,EAAUL,YAAnE,IAYF,OARIG,EAAUrB,OAAS,IACrBN,QAAQC,IAAI,kBAAoBwB,GAChCzB,QAAQC,IAAIqB,GACZtB,QAAQC,IAAIgB,GACZjB,QAAQC,IAAI0B,GACZ3B,QAAQC,IAAIF,EAAM4B,EAAU,MAGH,GAApBA,EAAUrB,UAKvB,SAASwB,EAAqBC,EAAUC,GACpC,OAAOA,EAAMJ,OAAO,SAACK,EAAGpB,GACxB,QAAIoB,EAAEC,SAAS5B,OAAS,KACpB2B,EAAEC,SAAS,KAAOH,GAAYE,EAAEC,SAAS,KAAOH,KAEnDI,IAAI,SAACF,EAAGpB,GACT,OAAIoB,EAAEC,SAAS,KAAOH,EAAiBE,EAAEC,SAAS,GACtCD,EAAEC,SAAS,KA+BzB,SAASE,EAAgBC,EAAML,GAE7B,IADA,IAAIM,EAAe,GACVzB,EAAI,EAAGA,EAAImB,EAAM1B,OAAQO,IAAK,CACrC,IAAI0B,EAAMF,EAAKG,QAAQR,EAAMnB,GAAGqB,SAAS,IACrCO,EAAMJ,EAAKG,QAAQR,EAAMnB,GAAGqB,SAAS,IACrCK,GAAO,GAAKE,GAAO,GAA0B,GAArBrC,KAAKsC,IAAID,EAAIF,IACvCD,EAAaK,KAAK9B,GAGtB,OAAOyB,EAwCX,SAASM,EAAcC,EAAMC,GAiB3B,IAhBA,IAAIC,EAAQ,CACVC,KAAM,kBACNC,QAAS7C,KAAKG,MAAoB,IAAdH,KAAKI,UACzBqC,KAAMA,EACNC,KAAMA,EAEN/C,MAAO,GAEPiC,MAAO,GAEPE,SAAU,GACVG,KAAM,GACNa,WAAW,EACXC,KAAK,GAGEtC,EAAI,EAAGA,GAAKgC,EAAMhC,IACzB,IAAK,IAAIQ,EAAI,EAAGA,GAAKyB,EAAMzB,IAAK,CAC9B,IAAI+B,EAAS,CACXC,EAAGhC,EAAE,EACLiC,EAAGzC,EAAE,GAEPkC,EAAMb,SAASS,KAAKS,GAIxB,IAAK,IAAIG,EAAM,EAAGA,GAAOV,EAAMU,IAAO,CAEpC,IAAK,IAAIC,EAAM,EAAGA,EAAMV,EAAMU,IAAO,CACnC,IAAIC,EAAU,CACZC,GAAIF,EAAI,EACRG,GAAIJ,EAAI,EACRK,GAAIJ,EAAI,EACRK,GAAIN,EAAI,EACRO,QAAQ,EACR/D,MAAO,GACPmC,SAAU,CACTqB,GAAMT,EAAK,GAAKU,EAChBD,GAAMT,EAAK,GAAKU,EAAM,IAErBD,EAAM,GACRE,EAAQ1D,MAAM4C,MAAMY,EAAI,GAAGT,EAAOU,GAEhCD,EAAMV,GACRY,EAAQ1D,MAAM4C,KAAMY,EAAKT,EAAOU,GAElCT,EAAMf,MAAMW,KAAKc,GAInB,GAAIF,EAAMV,EACR,IAAK,IAAIW,EAAM,EAAGA,GAAOV,EAAMU,IAAO,CACpC,IAAIO,EAAW,CACbL,GAAIF,EAAI,EACRG,GAAIJ,EAAI,EACRK,GAAIJ,EAAI,EACRK,GAAIN,EAAI,EACRO,QAAQ,EACR/D,MAAO,GACPmC,SAAU,CACPqB,GAAMT,EAAK,GAAKU,GAChBD,EAAI,IAAIT,EAAK,GAAKU,IAEnBA,EAAM,GACRO,EAAShE,MAAM4C,KAAMY,EAAKT,EAAOU,EAAI,GAEnCA,EAAMV,GACRiB,EAAShE,MAAM4C,KAAMY,EAAKT,EAAOU,GAEnCT,EAAMf,MAAMW,KAAKoB,IAKvB,IAAK,IAAIlD,EAAI,EAAGA,EAAIgC,EAAMhC,IACxB,IAAK,IAAIQ,EAAI,EAAGA,EAAIyB,EAAMzB,IAAK,CAC7B,IAAIC,EAAO,CACTC,SAAU,QACVmC,GAAIrC,EAAE,EACNsC,GAAI9C,EAAE,EACN+C,GAAIvC,EAAE,EACNwC,GAAIhD,EAAE,GAERkC,EAAMhD,MAAM4C,KAAKrB,GAKrB,IAAK,IAAIT,EAAI,EAAGA,EAAIkC,EAAMb,SAAS5B,OAAQO,IACzCkC,EAAMb,SAASrB,GAAGmD,WAAalC,EAAqBjB,EAAGkC,EAAMf,OAO/D,IAFA,IAAIiC,EAAU,EAAEpB,EAAK,IAAIC,EAAK,GAAG,GAExBjC,EAAI,EAAGA,EAAIoD,EAAQ3D,OAAQO,IAClCkC,EAAMb,SAAS+B,EAAQpD,IAAIqD,WAAW,QAOxC,IAFA,IAAIC,EAAQ,CAAC,GAEJtD,EAAI,EAAGA,EAAIsD,EAAM7D,OAAQO,IAChCkC,EAAMb,SAASiC,EAAMtD,IAAIqD,WAAW,OAatC,IAFA,IAAIE,EAzJN,SAASC,EAAWhC,EAAMH,EAAUF,EAAOjC,GACzC,GAAgD,QAA5CmC,EAASG,EAAKA,EAAK/B,OAAO,IAAI4D,WAAsB,CAEtD,IAAI5B,EAAeF,EAAgBC,EAAML,GAErCoC,EAAW,CACb/B,KAAMA,EACN/B,OAAQ+B,EAAK/B,OACbR,QAASwE,EAAiBvE,EAAOiC,EAAOM,IAE1C,OAAI8B,EAAStE,QAAQQ,OAAS,EAAU,KACjC8D,EAMT,IAAIG,EAAarC,EAASG,EAAKA,EAAK/B,OAAO,IAAI0D,WAAWpC,OAAO,SAAA4C,GAAC,OAAInC,EAAKG,QAAQgC,GAAK,IACxF,GAAyB,GAArBD,EAAWjE,OAEb,OAAO,KAKT,IAHA,IACImE,EADAC,EAAkBtE,KAAKI,SAAW,IAAO6B,EAAK/B,OAAS,GAGnDoE,IAAoBD,GAAe,CACzC,IAAIE,EAAeJ,EAAWnE,KAAKG,MAAMH,KAAKI,SAAS+D,EAAWjE,SAGlE,GADAmE,EAAgBJ,EADL3D,OAAAC,EAAA,EAAAD,CAAO2B,GAAPuC,OAAA,CAAaD,IACYzC,EAAUF,EAAOjC,GAClC,OAAO0E,EAC1BC,EAAkBtE,KAAKI,SAAW,IAAO6B,EAAK/B,OAAS,EAEzD,OAAO,KAyHQ+D,CAAW,CAACJ,EAAQ,IAAKlB,EAAMb,SAAUa,EAAMf,MAAOe,EAAMhD,OAElEc,EAAI,EAAGA,EAAIuD,EAAStE,QAAQQ,OAAQO,IAC3C,IAAK,IAAIQ,EAAI,EAAGA,EAAI+C,EAAStE,QAAQe,GAAGP,OAAQe,IAC9C0B,EAAMhD,MAAMqE,EAAStE,QAAQe,GAAGQ,IAAIwD,eAAiBhE,EAQzD,IAJA,IAEIiE,EAAS1E,KAAKG,MAAM,GAAAH,KAAKI,SAFb,GAIPK,EAAI,EAAGA,EAAIiE,EAAQjE,IAAK,CAC/B,IAAIkE,EAAS3E,KAAKG,MAAMH,KAAKI,SAASuC,EAAMf,MAAM1B,QAC9C8D,EAAS/B,KAAKG,QAAQuC,IAAW,IACrC/E,QAAQC,IAAI,iBAAmB8E,GAC/BhC,EAAMf,MAAM+C,GAAQjB,QAAS,GAK/B,IA1IiC,IAAAkB,EA0IZ,CAAC,aAAtBC,EAAA,EAAAA,EAAAD,EAAA1E,OAAA2E,IAAoC,CAClCxF,EADeuF,EAAAC,IACKpF,MAAMuE,EAAStE,QAASiD,EAAMhD,OAuBpD,OApBAgD,EAAMmC,UAAYnC,EAAMf,MAAMG,IAAI,SAAAF,GAAC,MAAK,CACtCkD,SAAS,KAGXpC,EAAMqC,YAAcrC,EAAMb,SAASC,IAAI,SAAAF,GAAC,MAAK,CAC3CkD,SAAS,KAGXpC,EAAMrB,UAAYqB,EAAMhD,MAAMoC,IAAI,SAAAF,GAAC,MAAK,CACtCoD,OAAO,KAGTtC,EAAMjD,QAAU,CAACiD,EAAMhD,MAAMoC,IAAI,SAACF,EAAGpB,GAAJ,OAAWA,KAI5CkC,EAAMqC,YAAYnB,EAAQ,IAAIkB,SAAQ,EACtCpC,EAAMV,KAAO,CAAC4B,EAAQ,IAGflB,EAGT,SAASuC,EAAaC,EAAWtE,EAAQuE,EAAgBzF,EAAOiC,EAAOM,GACrEkD,EAAexE,OAAOwE,EAAehD,QAAQ+C,GAAY,GACzDtE,EAAO0B,KAAK4C,GACZ,IAAIvB,EAAahC,EAAMJ,OAAO,SAACK,EAAGpB,GAChC,GAAIoB,EAAElC,MAAMO,OAAS,EAAG,OAAO,EAC/B,GAAIgC,EAAaE,QAAQ3B,IAAM,EAAG,OAAO,EACzC,IAAIgB,EACJ,GAAII,EAAElC,MAAM,KAAOwF,EAAW1D,EAAYI,EAAElC,MAAM,OAC7C,IAAIkC,EAAElC,MAAM,KAAOwF,EACnB,OAAO,EADuB1D,EAAYI,EAAElC,MAAM,GAEvD,QAAIyF,EAAehD,QAAQX,GAAa,KAEvCM,IAAI,SAACF,EAAGpB,GACT,OAAIoB,EAAElC,MAAM,KAAOwF,EAAkBtD,EAAElC,MAAM,GACjCkC,EAAElC,MAAM,KAd6D0F,GAAA,EAAAC,GAAA,EAAAC,OAAAC,EAAA,IAgBnF,QAAAC,EAAAC,EAAc9B,EAAd+B,OAAAC,cAAAP,GAAAI,EAAAC,EAAAG,QAAAC,MAAAT,GAAA,EAA0B,KAAjBU,EAAiBN,EAAAO,MAEpBZ,EAAehD,QAAQ2D,GAAK,GAChCb,EAAaa,EAAGlF,EAAQuE,EAAgBzF,EAAOiC,EAAOM,IAnB2B,MAAA+D,GAAAX,GAAA,EAAAC,EAAAU,EAAA,YAAAZ,GAAA,MAAAK,EAAAQ,QAAAR,EAAAQ,SAAA,WAAAZ,EAAA,MAAAC,IAuBrF,SAASrB,EAAiBvE,EAAOiC,EAAOM,GAGtC,IAFA,IAAIkD,EAAiBzF,EAAMoC,IAAI,SAACF,EAAGpB,GAAJ,OAAUA,IACrCf,EAAU,GACP0F,EAAelF,OAAS,GAAG,CAChC,IAAIW,EAAS,GACbqE,EAAaE,EAAe,GAAIvE,EAAQuE,EAAgBzF,EAAOiC,EAAOM,GACtExC,EAAQ6C,KAAK1B,GAGf,OAAOnB,EAKF,IAAMyG,EAAe,CACxBxD,MAAMrC,OAAA8F,EAAA,EAAA9F,CAAA,GACCkC,EAAc,EAAG,KAsKf6D,EAAUC,YAAgB,CACrC3D,MAnKY,WAAwC,IAAvC4D,EAAuCC,UAAAtG,OAAA,QAAAsF,IAAAgB,UAAA,GAAAA,UAAA,GAA/BL,EAAaxD,MAAO8D,EAAWD,UAAAtG,OAAA,EAAAsG,UAAA,QAAAhB,EAGpD,OAFA5F,QAAQC,IAAI4G,EAAOxH,MAEXwH,EAAOxH,MACb,IAAK,WACH,OAAOqB,OAAA8F,EAAA,EAAA9F,CAAA,GACFiG,EACA/D,EAAc,EAAG,IAExB,IAAK,cACH,OAAOlC,OAAA8F,EAAA,EAAA9F,CAAA,GACFiG,EADL,CAEEzB,UAAWyB,EAAM3E,MAAMG,IAAI,SAAAF,GAAC,MAAK,CAC/BkD,SAAS,KAGXC,YAAauB,EAAMzE,SAASC,IAAI,SAAAF,GAAC,MAAK,CAClCkD,SAAS,KAGbzD,UAAWiF,EAAM5G,MAAMoC,IAAI,SAAAF,GAAC,MAAK,CAC/BoD,OAAO,KAGTvF,QAAS,CAAC6G,EAAM5G,MAAMoC,IAAI,SAACF,EAAGpB,GAAJ,OAAWA,KAErCwB,KAAM,GAENa,WAAW,EAEXC,KAAK,IAGT,IAAK,eACHnD,QAAQC,IAAI4G,EAAOxH,MACnBW,QAAQC,IAAI4G,EAAOvH,IACnB,IAAIyC,EAAW8E,EAAOvH,GAClB8F,EAAW1E,OAAAC,EAAA,EAAAD,CAAOiG,EAAMvB,aAC5BA,EAAarD,GAAbrB,OAAA8F,EAAA,EAAA9F,CAAA,GAA6B0E,EAAYrD,IACzC,IAAIqB,EAASuD,EAAMzE,SAASH,GACxBM,EAAI3B,OAAAC,EAAA,EAAAD,CAAOiG,EAAMtE,MACjBa,GAAY,EACZC,GAAM,EAEV,IAAKC,EAAQ,OAAOuD,EAEpB,GAAIA,EAAMzD,UAAW,OAAOyD,EAE5B,IAAIG,EAAezE,EAAKA,EAAK/B,OAAO,GAChCyG,EAAoB1E,EAAKA,EAAK/B,OAAO,GAErCyE,EAAS4B,EAAM3E,MAAMgF,UAAU,SAAA/E,GACjC,OAAOA,EAAEC,SAASM,QAAQT,IAAa,GAClCE,EAAEC,SAASM,QAAQsE,IAAiB,IACnC7E,EAAE6B,SAENmD,EAAON,EAAM3E,MAAM+C,GAKvB,GAJA/E,QAAQC,IAAI,cAAgB8E,GAC5B/E,QAAQC,IAAIgH,GAGQ,IAAhB5E,EAAK/B,QAAqC,SAArB8C,EAAOc,WAC9B,OAAOyC,EAGJ,GAAmB,GAAftE,EAAK/B,QAAoC,SAArB8C,EAAOc,WAElC,OAAOyC,EAGJ,GAAI5E,GAAY+E,GAAgB/E,GAAYgF,EAC/C3B,EAAY/C,EAAK6E,OAAS,CACxB/B,SAAS,OAGR,IAAIC,EAAYrD,GAAUoD,QAE7B,OAAOwB,EAEJ,GAAItE,EAAK/B,OAAS,IAAM2G,EAE3B,OAAON,EAIPvB,EAAYrD,GAAUoD,SAAU,EAChC9C,EAAKM,KAAKZ,GACe,QAArBqB,EAAOc,aAEThB,GAAY,GAOhB,IAAIZ,EAAeF,EAAgBC,EAAMsE,EAAM3E,OAC3CkD,EAAYyB,EAAMzB,UAAU/C,IAAI,SAACF,EAAGpB,GACtC,OAAIyB,EAAaE,QAAQ3B,IAAM,EACtB,CACLsE,SAAS,GAIJ,CACLA,SAAS,KAKXrF,EAAUwE,EAAiBqC,EAAM5G,MAAO4G,EAAM3E,MAAOM,GAIzDa,GAAM,EASN,IAPA,IAAIzB,EAAYiF,EAAM5G,MAAMoC,IAAI,SAACgE,EAAGtF,GAChC,OAAOH,OAAA8F,EAAA,EAAA9F,CAAA,GACFiG,EAAMjF,UAAUb,GADrB,CAEEwE,OAAO,MAIJxE,EAAI,EAAGA,EAAIf,EAAQQ,OAAQO,IAAK,KAAAsG,GAAA,EAAAC,GAAA,EAAAC,OAAAzB,EAAA,IAEvC,QAAA0B,EAAAC,EAAczH,EAAQe,GAAtBkF,OAAAC,cAAAmB,GAAAG,EAAAC,EAAAtB,QAAAC,MAAAiB,GAAA,EAA0B,KAAjBhB,EAAiBmB,EAAAlB,MACxB1E,EAAUyE,GAAGlF,OAASJ,EACtB,IAAI2G,EAAK/H,EAAUkH,EAAM5G,MAAMoG,GAAG5E,UAAU5B,SAASwG,EAAGrG,EAAQe,GAAI8F,EAAM5G,MAAO2B,GAC5E8F,IAAIrE,GAAM,GACfzB,EAAUyE,GAAGd,MAAQmC,GANgB,MAAAnB,GAAAe,GAAA,EAAAC,EAAAhB,EAAA,YAAAc,GAAA,MAAAI,EAAAjB,QAAAiB,EAAAjB,SAAA,WAAAc,EAAA,MAAAC,IAqBzC,OAVY3G,OAAA8F,EAAA,EAAA9F,CAAA,GACPiG,EADO,CAEVvB,cACAF,YACAxD,YACAW,OACAa,YACAC,MACArD,YAGL,IAAK,WACF,OAAOY,OAAA8F,EAAA,EAAA9F,CAAA,GACFiG,EADL,CAEIrH,GAAIuH,EAAOvH,GACXF,KAAMyH,EAAOzH,KACb8D,WAAW,IAEjB,IAAK,cACH,OAAOyD,EAAMxE,IACX,SAAAsF,GAAI,OACFA,EAAKnI,KAAOuH,EAAOvH,GAAnBoB,OAAA8F,EAAA,EAAA9F,CAAA,GAA6B+G,EAA7B,CAAmCvE,WAAYuE,EAAKvE,YAAcuE,IAExE,QACE,OAAOd,cC/eEe,mLA5BJ,IAAAC,EACqCC,KAAKC,MAA5CvG,EADEqG,EACFrG,KAAMI,EADJiG,EACIjG,UAAWoG,EADfH,EACeG,SAAUC,EADzBJ,EACyBI,SAChC,OACEC,EAAAC,EAAAC,cAAA,OAAKC,UAAW,SAAW7G,EAAKC,UAAY,KAAOG,EAAU2D,MAAQ,SAAW,YAAa+C,MAAO,CAClGC,MAAOP,EACPQ,OAAQR,EACRS,KAAOjH,EAAKoC,IAAMoE,EAAWC,GAC7BS,IAAMlH,EAAKqC,IAAMmE,EAAWC,GAC5BvG,MAAOF,EAAKE,OAAS,kBATNiH,aC0CRC,mLAzCJ,IAAAf,EAC6CC,KAAKC,MAApDZ,EADEU,EACFV,KAAc/B,GADZyC,EACI5C,OADJ4C,EACYzC,WAAW4C,EADvBH,EACuBG,SAAUC,EADjCJ,EACiCI,SACxC,OAAId,EAAKvD,IAAMuD,EAAKrD,GAGhBoE,EAAAC,EAAAC,cAAA,OAAKC,UAAW,iBAAmBjD,EAAUC,QAAU,WAAa,KAAO8B,EAAKnD,OAAS,UAAY,IAAKsE,MAAO,CAC/GC,MAAON,EACPO,OAAQR,EACRS,KAAOtB,EAAKvD,IAAMoE,EAAWC,GAAYA,EACzCS,IAAMvB,EAAKtD,IAAMmE,EAAWC,MAO9BC,EAAAC,EAAAC,cAAA,OAAKC,UAAW,mBAAqBjD,EAAUC,QAAU,WAAa,KAAO8B,EAAKnD,OAAS,UAAY,IAAKsE,MAAO,CACjHC,MAAOP,EACPQ,OAAQP,EACRQ,KAAOtB,EAAKvD,IAAMoE,EAAWC,GAC7BS,IAAMvB,EAAKtD,IAAMmE,EAAWC,GAAYA,YArB3BU,aCsDRE,mLArDJ,IAAAhB,EACmDC,KAAKC,MAA1DzE,EADEuE,EACFvE,OAAkBgC,GADhBuC,EACM5F,SADN4F,EACgBvC,aAAa0C,EAD7BH,EAC6BG,SAAUC,EADvCJ,EACuCI,SAC9C,MAAyB,SAArB3E,EAAOc,WAET8D,EAAAC,EAAAC,cAAA,OAAKC,UAAW,WAAa/E,EAAOc,YAAc,KAAOkB,EAAYD,QAAU,WAAa,IAAKiD,MAAO,CACtGC,MAAgB,EAATN,EACPO,OAAiB,EAATP,EACRQ,KAAOnF,EAAOC,GAAKyE,EAAWC,GAAYA,EAAWA,EACrDS,IAAMpF,EAAOE,GAAKwE,EAAWC,GAAYA,EAAWA,KAK1B,QAArB3E,EAAOc,WAEd8D,EAAAC,EAAAC,cAAA,OAAKC,UAAW,WAAa/E,EAAOc,YAAc,KAAOkB,EAAYD,QAAU,WAAa,IAAKiD,MAAO,CACtGC,MAAgB,EAATN,EACPO,OAAiB,EAATP,EACRQ,KAAOnF,EAAOC,GAAKyE,EAAWC,GAAYA,EAAWA,EACrDS,IAAMpF,EAAOE,GAAKwE,EAAWC,GAAYA,EAAWA,KAOtDC,EAAAC,EAAAC,cAAA,OAAKC,UAAW,WAAa/E,EAAOc,YAAc,KAAOkB,EAAYD,QAAU,WAAa,IAAKiD,MAAO,CACtGC,MAAON,EACPO,OAAQP,EACRQ,KAAOnF,EAAOC,GAAKyE,EAAWC,GAAYA,EAC1CS,IAAMpF,EAAOE,GAAKwE,EAAWC,GAAYA,YA/BxBU,aCKnBG,cACJ,SAAAA,IAAc,IAAAC,EAAA,OAAAnI,OAAAoI,EAAA,EAAApI,CAAAkH,KAAAgB,IACZC,EAAAnI,OAAAqI,EAAA,EAAArI,CAAAkH,KAAAlH,OAAAsI,EAAA,EAAAtI,CAAAkI,GAAAK,KAAArB,QACKsB,QAAUL,EAAKK,QAAQC,KAAbzI,OAAA0I,EAAA,EAAA1I,QAAA0I,EAAA,EAAA1I,CAAAmI,KACfA,EAAKlC,MAAQ,GAHDkC,uEAKN5G,GAAG,IAAA0F,EACkBC,KAAKC,MAA3B9E,EADI4E,EACJ5E,MAAOxD,EADHoI,EACGpI,YAGR8D,EAAKpB,EAAEoH,YAAYC,QAAU1B,KAAK2B,IAAIC,WACtClG,EAAKrB,EAAEoH,YAAYI,QAAU7B,KAAK2B,IAAIG,UAItClG,EAAMpD,KAAKuJ,MAAMtG,EAAE,IAAK,EACxBE,EAAMnD,KAAKuJ,MAAMrG,EAAE,IAAK,GAC5BtD,QAAQC,IAAIoD,EAAE,KAAKC,EAAE,OAAOE,EAAI,KAAKD,GAEjCC,GAAO,GAAKD,GAAO,GAAKA,GAAOR,EAAMF,MAAQW,GAAOT,EAAMD,OAE5DvD,EADcgE,GAAKR,EAAMD,KAAK,GAAGU,oCAO5B,IAAAoG,EAAAhC,KACF7E,EAAS6E,KAAKC,MAAd9E,MACL,GAAKA,GAAUA,EAAMhD,OAAWgD,EAAMhD,MAAM,GAOvC,CACH,IAAI8J,EAAU,KAed,OAdI9G,EAAMG,YAAcH,EAAMI,IAC5B0G,EACE7B,EAAAC,EAAAC,cAAA,OAAKC,UAAU,gBAAf,UAKKpF,EAAMG,WAAaH,EAAMI,MAChC0G,EACE7B,EAAAC,EAAAC,cAAA,OAAKC,UAAU,gBAAf,YAMFH,EAAAC,EAAAC,cAAA,OAAKC,UAAW,UAAYpF,EAAMG,UAAY,aAAe,KAAQH,EAAMI,IAAM,OAAS,IAAM2G,IAAK,SAAA7H,GAAC,OAAK2H,EAAKL,IAAMtH,GAAIiH,QAAStB,KAAKsB,SAErInG,EAAMhD,MAAMoC,IAAI,SAACgE,EAAGtF,GAAJ,OAASmH,EAAAC,EAAAC,cAAC6B,EAAD,CACxBzI,KAAM6E,EACNzE,UAAWqB,EAAMrB,UAAUb,GAC3BiH,SAAU,GACVC,SAAU,OACXhF,EAAMf,MAAMG,IAAI,SAACF,EAAGpB,GAAJ,OAASmH,EAAAC,EAAAC,cAAC8B,EAAD,CACxB/C,KAAMhF,EACN8C,OAAQlE,EACRqE,UAAWnC,EAAMmC,UAAUrE,GAC3BiH,SAAU,GACVC,SAAU,OACXhF,EAAMb,SAASC,IAAI,SAACqC,EAAG3D,GAAJ,OAASmH,EAAAC,EAAAC,cAAC+B,EAAD,CAC3B7G,OAAQoB,EACRzC,SAAUlB,EACVuE,YAAarC,EAAMqC,YAAYvE,GAC/BiH,SAAU,GACVC,SAAU,OACX8B,GA1CL,OACE7B,EAAAC,EAAAC,cAAA,OAAKC,UAAU,SAAf,0BA/BgBM,aA0FTyB,cACb,SAAAvD,GAAK,MAAK,IAGV,SAAAwD,GAAQ,MAAK,CACX3K,WAAY,SAAAF,GAAE,OAAI6K,EAAS3K,EAAWF,KACtCH,QAAS,SAAAG,GAAE,OAAI6K,EAAShL,EAAQG,KAChCC,YAAa,SAAAD,GAAE,OAAI6K,EAAS5K,EAAYD,OAP7B4K,CASbtB,GCrGIwB,cACJ,SAAAA,IAAc,IAAAvB,EAAA,OAAAnI,OAAAoI,EAAA,EAAApI,CAAAkH,KAAAwC,IACZvB,EAAAnI,OAAAqI,EAAA,EAAArI,CAAAkH,KAAAlH,OAAAsI,EAAA,EAAAtI,CAAA0J,GAAAnB,KAAArB,QACKjB,MAAQ,GAFDkC,wEAwCL,IAAAe,EAAAhC,KAAAyC,EAC6BzC,KAAKjB,MAApC5D,EADEsH,EACFtH,MAAOuH,EADLD,EACKC,UAAWC,EADhBF,EACgBE,UAEvB,OACEvC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,iBAAiB2B,IAAK,SAAA7H,GAAC,OAAK2H,EAAKL,IAAMtH,GAAIiH,QAAStB,KAAKsB,SACpEoB,EAAatC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,aAAYH,EAAAC,EAAAC,cAACsC,EAAD,CAAWzH,MAAOuH,KAAuB,KACjFvH,EAASiF,EAAAC,EAAAC,cAAA,OAAKC,UAAU,gBAAeH,EAAAC,EAAAC,cAACsC,EAAD,CAAWzH,MAAOA,KAAmB,KAC5EwH,EAAavC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,aAAYH,EAAAC,EAAAC,cAACsC,EAAD,CAAWzH,MAAOwH,KAAuB,yDA1CzD1C,EAAOlB,GACrC,OAAKA,EAAM5D,OAAU8E,EAAM9E,MAQvB4D,EAAM5D,OAAS8E,EAAM9E,OAAS4D,EAAM5D,MAAME,SAAW4E,EAAM9E,MAAME,SAEnEjD,QAAQC,IAAI,aACL,CACLsK,UAAW1C,EAAM9E,MACjBA,MAAO,KACPuH,UAAW3D,EAAM5D,UAIhB4D,EAAM5D,MAAMG,WAAa2E,EAAM9E,MAAMG,YACpC2E,EAAM9E,MAAMI,IACdsH,WAAW,kBAAI5C,EAAM1I,WAAW,KAGhCsL,WAAW,kBAAI5C,EAAMrI,cAAc,MAIhC,CACH+K,UAAW,KACXxH,MAAO8E,EAAM9E,MACbuH,UAAW,OA7BN,CACHC,UAAW,KACXxH,MAAO8E,EAAM9E,MACbuH,UAAW,aAXO7B,aAmEbyB,cACb,SAAAvD,GAAK,MAAK,CACR5D,MAAO4D,EAAM5D,QAEf,SAAAoH,GAAQ,MAAK,CACX3K,WAAY,SAAAF,GAAE,OAAI6K,EAAS3K,EAAWF,KACtCH,QAAS,SAAAG,GAAE,OAAI6K,EAAShL,EAAQG,KAChCC,YAAa,SAAAD,GAAE,OAAI6K,EAAS5K,EAAYD,OAP7B4K,CASbE,GC7EIM,mLACK,IAAA/C,EACqBC,KAAKC,MAA5B1I,EADEwI,EACFxI,QAASK,EADPmI,EACOnI,WACd,OACEwI,EAAAC,EAAAC,cAAA,OAAKC,UAAU,QACbH,EAAAC,EAAAC,cAAA,UAAQgB,QAAS,kBAAM/J,MAAvB,YACA6I,EAAAC,EAAAC,cAAA,UAAQgB,QAAS,kBAAM1J,MAAvB,iBANeiJ,aAuBRyB,cACb,SAAAvD,GAAK,MAAK,CACR5D,MAAO4D,EAAM5D,QAEf,SAAAoH,GAAQ,MAAK,CACX3K,WAAY,SAAAF,GAAE,OAAI6K,EAAS3K,EAAWF,KACtCH,QAAS,SAAAG,GAAE,OAAI6K,EAAShL,EAAQG,OANrB4K,CAQbQ,GCnBaC,mLATX,OACE3C,EAAAC,EAAAC,cAAA,OAAKC,UAAU,OACXH,EAAAC,EAAAC,cAAC0C,EAAD,MACA5C,EAAAC,EAAAC,cAAC2C,EAAD,cALQpC,aCMEqC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCTN,IAAMC,EAAQC,YAAY3E,GAG1B4E,IAASC,OACLtD,EAAAC,EAAAC,cAACqD,EAAA,EAAD,CAAUJ,MAAOA,GACbnD,EAAAC,EAAAC,cAACsD,EAAD,OAEJC,SAASC,eAAe,SDiHtB,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.44a52bab.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import { combineReducers } from 'redux'\n\n\nlet nextTodoId = 0\nexport const newGame = text => ({\n  type: 'NEW_GAME',\n  id: nextTodoId++,\n  text\n})\n\nexport const visitVertex = id => ({\n  type: 'VISIT_VERTEX',\n  id\n})\n\nexport const resetLevel = id => ({\n  type: 'RESET_LEVEL',\n  id\n})\n\nconst tileTypes = {\n  blank: {\n    validate: () => true\n  },\n  sameColor: {\n    place: (regions, tiles) => {\n      console.log(\"placing sameColor tiles\");\n      // at least two colors, up to the number of regions\n      let availableColors = [\"black\", \"white\", \"red\", \"blue\", \"green\"];\n      let colorCount = Math.min(availableColors.length, Math.floor(Math.random() * (regions.length-2) + 2));\n\n      console.log(\"placing sameColor tiles - \" + colorCount);\n\n      let unclaimedRegions = [...regions.keys()];\n      for (let i = 0; i < colorCount; i++) {\n        let ri = Math.floor(Math.random()*unclaimedRegions.length);\n        let regionId = unclaimedRegions[ri];\n        unclaimedRegions.splice(ri, 1);\n        let region = regions[regionId];\n        let maxInRegion = Math.ceil(region.length/2);\n        let minInRegion = 1;\n        let countInRegion = Math.floor(Math.random()*(maxInRegion-minInRegion)+minInRegion);\n        for (let j = 0; j < countInRegion; j++) {\n          let tile = tiles[region[Math.floor(Math.random()*region.length)]];\n          if (tile.tileType != \"blank\") continue;\n          tile.tileType = \"sameColor\";\n          tile.color = availableColors[i];\n        }\n\n      }\n\n    },\n    validate: (tileId, region, tiles, tileState) => {\n      let tile = tiles[tileId];\n      let conflicts = region.filter(id => {\n        if (id == tileId) return false;\n        let otherTile = tiles[id];\n        if (tile.tileType == otherTile.tileType && tile.color != otherTile.color) {\n          return true;\n        }\n      });\n      if (conflicts.length > 0) {\n        console.log(\"failed on tile \" + tileId);\n        console.log(tile);\n        console.log(region);\n        console.log(conflicts);\n        console.log(tiles[conflicts[0]]);\n\n      }\n      return conflicts.length == 0;\n    }\n  }\n}\n\nfunction neighbouringVertices(vertexId, edges) {\n    return edges.filter((e, i) => {\n    if (e.vertices.length < 2) return false;\n    if (e.vertices[0] === vertexId || e.vertices[1] === vertexId) return true;\n    else return false;\n  }).map((e, i) => {\n    if (e.vertices[0] === vertexId) return e.vertices[1];\n    else return e.vertices[0];\n  });\n}\n\n\nfunction extendPath(path, vertices, edges, solutions) {\n\n  // all unbroken edges\n  let nextPoints = vertices[path[path.length-1]].neighbours;\n  for (let i = 0; i < nextPoints.length; i++) {\n    let nextVertexId = nextPoints[i];\n    // can't revisit a node\n    if (path.indexOf(nextVertexId) >= 0) continue;\n    let newPath = [...path, nextVertexId];\n    //console.log(newPath);\n    if (newPath.length > 20) continue;\n    if (vertices[nextVertexId].vertexType == \"exit\") {\n      // this may be a valid solution\n      let solution = {\n        path: newPath,\n        length: newPath.length,\n        regions: []\n        }\n      solutions.push(solution);\n    }\n    else {\n      extendPath(newPath, vertices, edges, solutions);\n    }\n  }\n}\n\n  function getVisitedEdges(path, edges) {\n    let visitedEdges = [];\n    for (let i = 0; i < edges.length; i++) {\n      let pi1 = path.indexOf(edges[i].vertices[0]);\n      let pi2 = path.indexOf(edges[i].vertices[1]);\n      if (pi1 >= 0 && pi2 >= 0 && Math.abs(pi2-pi1) == 1) {\n        visitedEdges.push(i);\n      }\n    }\n    return visitedEdges;\n  }\n\n\nfunction randomPath(path, vertices, edges, tiles) {\n  if (vertices[path[path.length-1]].vertexType == \"exit\") {\n    // this may be a valid solution\n    let visitedEdges = getVisitedEdges(path, edges);\n\n    let solution = {\n      path: path,\n      length: path.length,\n      regions: calculateRegions(tiles, edges, visitedEdges)\n      }\n    if (solution.regions.length < 4) return null;\n    return solution;\n  }\n\n  // otherwise, see if a random edge leads to a solution\n\n  // all unvisited neighbours\n  let nextPoints = vertices[path[path.length-1]].neighbours.filter(v => path.indexOf(v) < 0);\n  if (nextPoints.length == 0) {\n    // dead end\n    return null;\n  }\n  let shouldBacktrack = Math.random() > 0.5 && path.length > 1;\n  let foundSolution;\n\n  while (!shouldBacktrack && !foundSolution) {\n    let nextVertexId = nextPoints[Math.floor(Math.random()*nextPoints.length)];\n    let newPath = [...path, nextVertexId];\n    foundSolution = randomPath(newPath, vertices, edges, tiles);\n    if (foundSolution) return foundSolution;\n    shouldBacktrack = Math.random() > 0.5 && path.length > 1;\n  }\n  return null;\n}\n\n\nfunction generateLevel(rows, cols) {\n  let level = {\n    name: \"Generated Level\",\n    levelId: Math.floor(Math.random()*10000000),\n    rows: rows,\n    cols: cols,\n    // 8x8\n    tiles: [],\n    // 8h, 9v\n    edges: [],\n    // 9x9\n    vertices: [],\n    path: [],\n    completed: false,\n    won: false,\n  }\n\n  for (let i = 0; i <= rows; i++) {\n    for (let j = 0; j <= cols; j++) {\n      let vertex = {\n        x: j+1,\n        y: i+1,\n      };\n      level.vertices.push(vertex);\n    }\n  }\n\n  for (let row = 0; row <= rows; row++) {\n    // add top edge\n    for (let col = 0; col < cols; col++) {\n      let topEdge = {\n        x1: col+1,\n        y1: row+1,\n        x2: col+2,\n        y2: row+1,\n        broken: false,\n        tiles: [],\n        vertices: [\n        (row)*(cols+1) + col,\n        (row)*(cols+1) + col + 1]\n      };\n      if (row > 0) {\n        topEdge.tiles.push((row-1)*cols + col)\n      }\n      if (row < rows) {\n        topEdge.tiles.push((row)*cols + col)\n      }\n      level.edges.push(topEdge);\n    }\n\n    // add left side if not below last row\n    if (row < rows) {\n      for (let col = 0; col <= cols; col++) {\n        let leftEdge = {\n          x1: col+1,\n          y1: row+1,\n          x2: col+1,\n          y2: row+2,\n          broken: false,\n          tiles: [],\n          vertices: [\n            (row)*(cols+1) + col,\n            (row+1)*(cols+1) + col]\n        };\n        if (col > 0) {\n          leftEdge.tiles.push((row)*cols + col-1)\n        }\n        if (col < cols) {\n          leftEdge.tiles.push((row)*cols + col)\n        }\n        level.edges.push(leftEdge);\n      }\n    }\n  }\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let tile = {\n        tileType: \"blank\",\n        x1: j+1,\n        y1: i+1,\n        x2: j+2,\n        y2: i+2\n      };\n      level.tiles.push(tile);\n    }\n  }\n\n\n  for (let i = 0; i < level.vertices.length; i++) {\n    level.vertices[i].neighbours = neighbouringVertices(i, level.edges);\n  }\n\n\n  // add an entry\n  let entries = [(rows+1)*(cols+1)-5];\n\n  for (let i = 0; i < entries.length; i++) {\n    level.vertices[entries[i]].vertexType=\"entry\";\n  }\n\n\n  // add an exit\n  let exits = [4];\n\n  for (let i = 0; i < exits.length; i++) {\n    level.vertices[exits[i]].vertexType=\"exit\";\n  }\n\n\n // let solutions = [];\n\n\n//  for (let i = 0; i < entries.length; i++) {\n//    extendPath([entries[i]], level.vertices, level.edges, solutions)\n//  }\n\n  let solution = randomPath([entries[0]], level.vertices, level.edges, level.tiles)\n\n  for (let i = 0; i < solution.regions.length; i++) {\n    for (let j = 0; j < solution.regions[i].length; j++) {\n      level.tiles[solution.regions[i][j]].solutionRegion = i;\n    }\n  }\n\n  let minBreaks = 5;\n  let maxBreaks = 20;\n  let breaks = Math.floor(Math.random()*(maxBreaks-minBreaks)+minBreaks);\n  // add random broken edges\n  for (let i = 0; i < breaks; i++) {\n    let edgeId = Math.floor(Math.random()*level.edges.length);\n    if (solution.path.indexOf(edgeId) >= 0) continue;\n    console.log(\"breaking edge \" + edgeId);\n    level.edges[edgeId].broken = true;\n  }\n\n  // add tiles\n\n  for (let tileType of [\"sameColor\"]) {\n    tileTypes[tileType].place(solution.regions, level.tiles)\n  }\n\n  level.edgeState = level.edges.map(e => ({\n    visited: false\n  }));\n\n  level.vertexState = level.vertices.map(e => ({\n    visited: false\n  }));\n\n  level.tileState = level.tiles.map(e => ({\n    valid: true\n  }));\n\n  level.regions = [level.tiles.map((e, i) => (i))];\n\n  // for testing\n\n  level.vertexState[entries[0]].visited=true;\n  level.path = [entries[0]];\n\n\n  return level;\n}\n\nfunction expandRegion(startTile, region, unmatchedTiles, tiles, edges, visitedEdges) {\n  unmatchedTiles.splice(unmatchedTiles.indexOf(startTile), 1);\n  region.push(startTile);\n  let neighbours = edges.filter((e, i) => {\n    if (e.tiles.length < 2) return false;\n    if (visitedEdges.indexOf(i) >= 0) return false;\n    let otherTile;\n    if (e.tiles[0] === startTile) otherTile = e.tiles[1];\n    else if (e.tiles[1] === startTile) otherTile = e.tiles[0];\n    else return false;\n    if (unmatchedTiles.indexOf(otherTile) < 0) return false;\n    return true;\n  }).map((e, i) => {\n    if (e.tiles[0] === startTile) return e.tiles[1];\n    else return e.tiles[0];\n  });\n  for (let t of neighbours) {\n    // tile may have matched since the filtering step\n    if (unmatchedTiles.indexOf(t) < 0) continue;\n    expandRegion(t, region, unmatchedTiles, tiles, edges, visitedEdges);\n  }\n}\n\nfunction calculateRegions(tiles, edges, visitedEdges) {\n  let unmatchedTiles = tiles.map((e, i) => i);\n  let regions = [];\n  while (unmatchedTiles.length > 0) {\n    let region = [];\n    expandRegion(unmatchedTiles[0], region, unmatchedTiles, tiles, edges, visitedEdges)\n    regions.push(region);\n  }\n\n  return regions;\n}\n\n\n\nexport const initialState = {\n    level: {\n        ...generateLevel(8, 8),\n    }\n};\n\nconst level = (state = initialState.level, action) => {\n  console.log(action.type)\n\n  switch (action.type) {\n    case 'NEW_GAME':\n      return {\n        ...state,\n        ...generateLevel(8, 8)\n      }\n    case 'RESET_LEVEL':\n      return {\n        ...state,\n        edgeState: state.edges.map(e => ({\n          visited: false\n        })),\n\n        vertexState: state.vertices.map(e => ({\n            visited: false\n          })),\n\n        tileState: state.tiles.map(e => ({\n          valid: true\n        })),\n\n        regions: [state.tiles.map((e, i) => (i))],\n\n        path: [],\n\n        completed: false,\n\n        won: false,\n\n      }\n    case 'VISIT_VERTEX':\n      console.log(action.type)\n      console.log(action.id)\n      let vertexId = action.id;\n      let vertexState = [...state.vertexState];\n      vertexState [vertexId] = {...vertexState[vertexId]};\n      let vertex = state.vertices[vertexId];\n      let path = [...state.path];\n      let completed = false;\n      let won = false;\n\n      if (!vertex) return state;\n      // no need to keep going once completed\n      if (state.completed) return state;\n\n      let lastVertexId = path[path.length-1];\n      let backtrackVertexId = path[path.length-2]\n\n      let edgeId = state.edges.findIndex(e => {\n        return e.vertices.indexOf(vertexId) >= 0\n          && e.vertices.indexOf(lastVertexId) >= 0\n          && !e.broken\n      })\n      let edge = state.edges[edgeId];\n      console.log(\"Found edge \" + edgeId);\n      console.log(edge);\n\n      // if path is empty, must visit a start point\n      if (path.length === 0 && vertex.vertexType != \"entry\") {\n        return state;\n      }\n      // if path has only entry point, visiting another entry starts a new path\n      else if (path.length == 1 && vertex.vertexType == \"entry\") {\n        // todo: reset path/level state\n        return state;\n      }\n      // backtrack\n      else if (vertexId == lastVertexId || vertexId == backtrackVertexId) {\n        vertexState[path.pop()] = {\n          visited: false\n        }\n      }\n      else if (vertexState[vertexId].visited) {\n        // can't visit twice\n        return state;\n      }\n      else if (path.length > 0 && !edge) {\n        // no valid edge\n        return state;\n      }\n      else {\n        // visiting a new vertex\n        vertexState[vertexId].visited = true;\n        path.push(vertexId);\n        if (vertex.vertexType == \"exit\") {\n          // level completed - check if won\n          completed = true;\n        }\n\n      }\n\n\n\n      let visitedEdges = getVisitedEdges(path, state.edges);\n      let edgeState = state.edgeState.map((e, i) => {\n        if (visitedEdges.indexOf(i) >= 0) {\n          return {\n            visited: true\n          }\n        }\n        else {\n          return {\n            visited: false\n          }\n        }\n      })\n\n      let regions = calculateRegions(state.tiles, state.edges, visitedEdges);\n      //console.log(\"Current regions: \")\n      //console.log(regions);\n      // now validate the regions against the rules for each file\n      won = true;\n\n      let tileState = state.tiles.map((t, i) => {\n          return {\n            ...state.tileState[i],\n            valid: true\n          }\n      });\n\n      for (let i = 0; i < regions.length; i++) {\n        // validate each region's tiles. if any is invalid, mutate tileState and set won to false;\n        for (let t of regions[i]) {\n          tileState[t].region = i\n          let tv = tileTypes[state.tiles[t].tileType].validate(t, regions[i], state.tiles, tileState);\n          if (!tv) won = false;\n          tileState[t].valid = tv;\n        }\n      }\n\n\n      let newState = {\n        ...state,\n        vertexState,\n        edgeState,\n        tileState,\n        path,\n        completed,\n        won,\n        regions\n      };\n      return newState;\n   case 'ADD_TODO':\n      return {\n        ...state,\n          id: action.id,\n          text: action.text,\n          completed: false\n      }\n    case 'TOGGLE_TODO':\n      return state.map(\n        todo =>\n          todo.id === action.id ? { ...todo, completed: !todo.completed } : todo\n      )\n    default:\n      return state\n  }\n};\n\nexport const reducer = combineReducers({\n  level\n})\n\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nclass TileView extends Component {\n  render() {\n    let {tile, tileState, tileSize, edgeSize} = this.props;\n    return (\n      <div className={'tile ' + (tile.tileType || \"\") + (tileState.valid ? \" valid\" : \" invalid\")} style={{\n        width: tileSize,\n        height: tileSize,\n        left: (tile.x1 * (tileSize + edgeSize)),\n        top: (tile.y1 * (tileSize + edgeSize)),\n        color: tile.color || \"black\"\n      }}>\n      </div>\n    );\n  }\n}\n\nTileView.propTypes = {\n  tile: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    completed: PropTypes.bool.isRequired,\n    text: PropTypes.string.isRequired\n  }).isRequired,\n  tileState: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    completed: PropTypes.bool.isRequired,\n    text: PropTypes.string.isRequired\n  }).isRequired\n}\n\nexport default TileView","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nclass EdgeView extends Component {\n  render() {\n    let {edge, edgeId, edgeState, tileSize, edgeSize} = this.props;\n    if (edge.x1 == edge.x2) {\n      // vertical\n      return (\n        <div className={\"edge vertical\" + (edgeState.visited ? \" visited\" : \"\") + (edge.broken ? \" broken\" : \"\")} style={{\n          width: edgeSize,\n          height: tileSize,\n          left: (edge.x1 * (tileSize + edgeSize) - edgeSize),\n          top: (edge.y1 * (tileSize + edgeSize))\n        }}>\n        </div>\n      );\n    }\n    else {\n      return (\n        <div className={\"edge horizontal\" + (edgeState.visited ? \" visited\" : \"\") + (edge.broken ? \" broken\" : \"\")} style={{\n          width: tileSize,\n          height: edgeSize,\n          left: (edge.x1 * (tileSize + edgeSize)),\n          top: (edge.y1 * (tileSize + edgeSize) - edgeSize)\n        }}>\n        </div>\n      );\n    }\n  }\n}\n\nEdgeView.propTypes = {\n  edge: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    completed: PropTypes.bool.isRequired,\n    text: PropTypes.string.isRequired\n  }).isRequired,\n  edgeState: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    completed: PropTypes.bool.isRequired,\n    text: PropTypes.string.isRequired\n  }).isRequired\n}\n\nexport default EdgeView","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nclass VertexView extends Component {\n  render() {\n    let {vertex, vertexId, vertexState, tileSize, edgeSize} = this.props;\n    if (vertex.vertexType == \"entry\") {\n    return (\n      <div className={'vertex ' + (vertex.vertexType || \"\") + (vertexState.visited ? \" visited\" : \"\")} style={{\n        width: edgeSize*3,\n        height: edgeSize*3,\n        left: (vertex.x * (tileSize + edgeSize) - edgeSize - edgeSize),\n        top: (vertex.y * (tileSize + edgeSize) - edgeSize - edgeSize)\n      }}>\n      </div>\n    );\n    }\n    else if (vertex.vertexType == \"exit\") {\n    return (\n      <div className={'vertex ' + (vertex.vertexType || \"\") + (vertexState.visited ? \" visited\" : \"\")} style={{\n        width: edgeSize*3,\n        height: edgeSize*3,\n        left: (vertex.x * (tileSize + edgeSize) - edgeSize - edgeSize),\n        top: (vertex.y * (tileSize + edgeSize) - edgeSize - edgeSize)\n      }}>\n      </div>\n    );\n    }\n    else {\n          return (\n      <div className={'vertex ' + (vertex.vertexType || \"\") + (vertexState.visited ? \" visited\" : \"\")} style={{\n        width: edgeSize,\n        height: edgeSize,\n        left: (vertex.x * (tileSize + edgeSize) - edgeSize),\n        top: (vertex.y * (tileSize + edgeSize) - edgeSize)\n      }}>\n\n      </div>\n    );\n    }\n\n  }\n}\n\nVertexView.propTypes = {\n  vertex: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    completed: PropTypes.bool.isRequired,\n    text: PropTypes.string.isRequired\n  }).isRequired,\n  vertexState: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    completed: PropTypes.bool.isRequired,\n    text: PropTypes.string.isRequired\n  }).isRequired\n}\n\nexport default VertexView","import { connect } from 'react-redux'\nimport { newGame, resetLevel, visitVertex } from './store'\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport TileView from './TileView';\nimport EdgeView from './EdgeView';\nimport VertexView from './VertexView';\n\nclass GameBoard extends Component {\n  constructor() {\n    super();\n    this.onClick = this.onClick.bind(this);\n    this.state = {}\n  }\n  onClick(e) {\n    let {level, visitVertex} = this.props;\n    //console.log(e);\n    //console.log(e.nativeEvent);\n    let x = (e.nativeEvent.clientX - this.div.offsetLeft);\n    let y = (e.nativeEvent.clientY - this.div.offsetTop);\n\n    // find nearest vertex\n\n    let col = Math.round(x/60) -1;\n    let row = Math.round(y/60) -1;\n    console.log(x+\", \"+y+\" => \"+col+\", \"+row)\n\n    if (col >= 0 && row >= 0 && row <= level.rows && col <= level.cols) {\n      let vertexId =row*(level.cols+1)+col;\n      visitVertex(vertexId);\n    }\n\n  }\n\n\n  render() {\n    let {level} = this.props;\n    if (!level || !level.tiles || ! level.tiles[0]) {\n      return (\n        <div className=\"board\">\n          No game loaded;\n        </div>\n        )\n    }\n    else {\n      let overlay = null;\n      if (level.completed && !level.won) {\n        overlay = (\n          <div className=\"boardOverlay\">\n            Failed\n          </div>\n        )\n      }\n      else if (level.completed && level.won) {\n        overlay = (\n          <div className=\"boardOverlay\">\n            You win\n          </div>\n          )\n      }\n      return (\n        <div className={\"board \" + (level.completed ? \" completed\" : \"\")  + (level.won ? \" won\" : \"\") } ref={e => (this.div = e)} onClick={this.onClick}>\n\n          {level.tiles.map((t, i)=>(<TileView\n            tile={t}\n            tileState={level.tileState[i]}\n            tileSize={50}\n            edgeSize={10} />))}\n          {level.edges.map((e, i)=>(<EdgeView\n            edge={e}\n            edgeId={i}\n            edgeState={level.edgeState[i]}\n            tileSize={50}\n            edgeSize={10} />))}\n          {level.vertices.map((v, i)=>(<VertexView\n            vertex={v}\n            vertexId={i}\n            vertexState={level.vertexState[i]}\n            tileSize={50}\n            edgeSize={10} />))}\n          {overlay}\n        </div>\n      );\n    }\n  }\n}\n\nGameBoard.propTypes = {\n  todos: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.number.isRequired,\n      completed: PropTypes.bool.isRequired,\n      text: PropTypes.string.isRequired\n    }).isRequired\n  ).isRequired,\n  toggleTodo: PropTypes.func.isRequired\n}\n\nexport default connect(\n  state => ({\n   // level: state.level,\n  }),\n  dispatch => ({\n    resetLevel: id => dispatch(resetLevel(id)),\n    newGame: id => dispatch(newGame(id)),\n    visitVertex: id => dispatch(visitVertex(id))\n  })\n)(GameBoard);","import { connect } from 'react-redux'\nimport { newGame, resetLevel, visitVertex } from './store'\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport GameBoard from './GameBoard';\n\nclass GameContainer extends Component {\n  constructor() {\n    super();\n    this.state = {}\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    if (!state.level || !props.level) {\n      return {\n          nextLevel: null,\n          level: props.level,\n          prevLevel: null\n      };\n    }\n\n    if (state.level && props.level && state.level.levelId != props.level.levelId) {\n      // resetting to new level\n      console.log(\"resetting\");\n      return {\n        nextLevel: props.level,\n        level: null,\n        prevLevel: state.level\n      };\n    }\n\n    if (!state.level.completed && props.level.completed) {\n      if (props.level.won) {\n        setTimeout(()=>props.newGame(), 500);\n      }\n      else {\n        setTimeout(()=>props.resetLevel(), 1000);\n      }\n    }\n\n    return {\n        nextLevel: null,\n        level: props.level,\n        prevLevel: null\n    };\n  }\n\n  render() {\n    let {level, prevLevel, nextLevel} = this.state;\n\n    return (\n      <div className=\"boardcontainer\" ref={e => (this.div = e)} onClick={this.onClick}>\n        {(prevLevel ? (<div className=\"prevLevel\"><GameBoard level={prevLevel} /></div>) : null)}\n        {(level ? (<div className=\"currentLevel\"><GameBoard level={level} /></div>) : null)}\n        {(nextLevel ? (<div className=\"nextLevel\"><GameBoard level={nextLevel} /></div>) : null)}\n\n      </div>\n    );\n\n  }\n}\n\nGameContainer.propTypes = {\n  todos: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.number.isRequired,\n      completed: PropTypes.bool.isRequired,\n      text: PropTypes.string.isRequired\n    }).isRequired\n  ).isRequired,\n  toggleTodo: PropTypes.func.isRequired\n}\n\nexport default connect(\n  state => ({\n    level: state.level,\n  }),\n  dispatch => ({\n    resetLevel: id => dispatch(resetLevel(id)),\n    newGame: id => dispatch(newGame(id)),\n    visitVertex: id => dispatch(visitVertex(id))\n  })\n)(GameContainer);","import { connect } from 'react-redux'\nimport { newGame, resetLevel } from './store'\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nclass GameMenu extends Component {\n  render() {\n    let {newGame, resetLevel} = this.props;\n    return (\n      <div className=\"menu\">\n        <button onClick={() => newGame()}>New Game</button>\n        <button onClick={() => resetLevel()}>Retry</button>\n      </div>\n    );\n  }\n}\n\nGameMenu.propTypes = {\n  todos: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.number.isRequired,\n      completed: PropTypes.bool.isRequired,\n      text: PropTypes.string.isRequired\n    }).isRequired\n  ).isRequired,\n  toggleTodo: PropTypes.func.isRequired\n}\n\nexport default connect(\n  state => ({\n    level: state.level\n  }),\n  dispatch => ({\n    resetLevel: id => dispatch(resetLevel(id)),\n    newGame: id => dispatch(newGame(id))\n  })\n)(GameMenu);","import React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport GameContainer from './GameContainer';\nimport GameMenu from './GameMenu';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n          <GameContainer />\n          <GameMenu />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport { reducer } from './store'\n\nconst store = createStore(reducer)\n\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}